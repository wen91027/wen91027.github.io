<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>真實煉金：化合之戰</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400&display=swap" rel="stylesheet" />
  <style>
    body { margin:0; background:#0d1321; color:#fff; font-family:'Orbitron',sans-serif; text-align:center; }
    .toast { position:fixed; top:150px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); color:#f55; padding:8px 16px; border:1px solid #f55; border-radius:4px; z-index:2000; opacity:0; transition:opacity 0.3s; }
    .toast.show { opacity:1; }
    .game-container { display:flex; flex-direction:column; align-items:center; padding:1em; }
    .board { width:90%; max-width:800px; background:#1a242f; border:2px solid #444; border-radius:10px; padding:1em; position:relative; }
    .overlay { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:1000; }
    .overlay button { margin-top:1em; }
    .hp-section { display:flex; align-items:center; justify-content:center; margin:8px 0; }
    .hp-label { margin-right:8px; }
    .hp-bar { flex:1; background:#222; border:1px solid #0ff; border-radius:4px; height:16px; margin:0 8px; overflow:hidden; }
    .hp-inner { background:#0ff; height:100%; }
    .zone { margin:12px 0; }
    .zone-title { color:#ccc; margin-bottom:4px; }
    .hand { display:flex; flex-wrap:wrap; justify-content:center; }
    .field { display:flex; flex-wrap:nowrap; justify-content:flex-start; overflow-x:auto; }
    .card { border:1px solid #555; border-radius:6px; padding:6px; margin:4px; transition:transform .2s; display:flex; flex-direction:column; align-items:center; }
    .card:hover { transform:translateY(-4px); }
    .card.element { width:50px; height:70px; background:#1f2a36; cursor:pointer; position:relative; }
    .card.element.inert { background:#555; }
    .card.element.alkali { background:#a00; }
    .card.element .symbol { font-size:1.2em; margin-top:4px; }
    .card.element .number { position:absolute; top:4px; right:6px; font-size:0.8em; color:#0ff; }
    .card.element .defense { position:absolute; bottom:4px; width:100%; font-size:0.6em; color:#fff; text-align:center; }
    .card.element .explode { position:absolute; bottom:4px; width:100%; font-size:0.6em; color:#ff0; text-align:center; }
    .card.element.selected { border-color:#0f0; box-shadow:0 0 6px #0f0; }
    .card.molecule { width:80px; min-height:60px; background:#14232e; cursor:pointer; position:relative; }
    /* effect-specific backgrounds */
    .card.molecule.corrosion { background:#661100; }
    .card.molecule.poison    { background:#440066; }
    .card.molecule.burn      { background:#663300; }
    .card.molecule.recover   { background:#00AEAE; border:2px solid #fff; box-shadow:0 0 8px #fff;}
    .card.molecule.inert     { background:#555; border:2px solid #fff; box-shadow:0 0 8px #fff; pointer-events:none; display:flex; flex-direction:column; justify-content:center; align-items:center; }
    .card.molecule.inert .symbol    { font-size:1em; margin:4px 0; }
    .card.molecule.inert .block-info { font-size:0.8em; color:#fff; }
    .card.molecule.recover .symbol     { font-size:1em; margin-top:8px; }
    .card.molecule.recover .recover-info { position:absolute; bottom:4px; width:100%; font-size:0.6em; color:#fff; text-align:center; }
    .card.molecule.selected { border:2px solid #0f0; box-shadow:0 0 6px #0f0; }
    .controls { margin:8px 0; }
    button { font-family:'Orbitron',sans-serif; background:#112233; color:#0ff; border:1px solid #0ff; border-radius:4px; padding:6px 12px; margin:0 4px; cursor:pointer; transition:background 0.2s; }
    button:hover:enabled { background:#334455; }
    button:disabled { opacity:0.5; cursor:not-allowed; }
    .prompt { color:#8cf; margin-top:4px; }
    .log { text-align:center; max-height:120px; overflow-y:auto; background:#112233; padding:8px; border:1px solid #333; border-radius:4px; margin-top:8px; font-size:1em; }
    @media (orientation: portrait) {
    .board { width:100%; padding:0.5em; }
    .hp-section { flex-direction: column; }
    .hp-label, .hp-text { margin: 2px 0; }
    .hp-bar { flex: none !important; width: 100% !important; margin: 4px 0; }
    .zone-title { font-size: 0.9em; }
    .hand { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 0.25em; }
    .field { display: flex; flex-wrap: nowrap; overflow-x: auto; padding-bottom: 4px; }
    .card { margin: 2px; padding: 4px; min-width: 60px; }
    .card.element { width: auto; height: 60px; }
    .card.molecule { width: auto; min-height: 50px; }
    button { width: 100%; margin: 4px 0; padding: 8px; }
    .controls { flex-direction: column; }
    .prompt, .log { font-size: 0.8em; }
  }
    .hp-section { flex-direction: column; }
    .hp-label, .hp-text { margin: 2px 0; }
    .hp-bar { flex: none !important; width: 100% !important; margin: 4px 0; }
    .zone-title { font-size: 0.9em; }
    .hand, .field { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 0.25em; }
    .card { margin: 2px; padding: 4px; min-width: 60px; }
    .card.element { width: auto; height: 60px; }
    .card.molecule { width: auto; min-height: 50px; }
    button { width: 100%; margin: 4px 0; padding: 8px; }
    .controls { flex-direction: column; }
    .prompt, .log { font-size: 0.8em; }
    .bg-logo {
  width: 100%;
  max-width: 100%;
  height: auto;
  display: block;
  margin: 0 auto 1em;
}
  }
  </style>
      </head>
<body>
  <div id="toast" class="toast"></div>
  <div id="root"></div>
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <script type="text/babel">
    const MAX_HP = 128;
    const ELEMENTS = ["H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca"];
    const ALKALI = ["Li","Na","K"]; // 1A族
    const WEIGHTS = {H:16,C:10,O:12,N:8,Na:5,He:2,Ne:1,Ar:0.5};
    const drawPool = [];
    ELEMENTS.forEach(e => {
      const w = WEIGHTS[e]||3;
      for (let i=0;i<Math.round(w*2);i++) drawPool.push(e);
    });
    function drawCard(){
      const el = drawPool[Math.floor(Math.random()*drawPool.length)];
      return { el, corroded:false, usable:['He','Ne','Ar'].includes(el) };
    }
    const MOLECULES = [
      { name: "一氧化氮", formula: { N: 1, O: 1 }, effect: "poison" },
{ name: "一氧化碳", formula: { C: 1, O: 1 }, effect: "poison" },
{ name: "乙炔", formula:{C:2,H:2}, effect:"burn" },
{ name: "乙烯", formula:{C:2,H:4}, effect:"burn" },
{ name: "二氧化碳", formula: { C: 1, O: 2 }, effect: "none" },
{ name: "水", formula:{H:2,O:1}, effect:"recover" },
{ name: "甲烷", formula:{C:1,H:4}, effect:"burn" },
{ name: "光氣", formula:{C:1,O:1,Cl:2}, effect:"poison" },
{ name: "氟化鈉", formula: { Na: 1, F: 1 }, effect: "none" },
{ name: "氟化鈹", formula: { Be: 1, F: 2 }, effect: "none" },
{ name: "氟化鉀", formula: { K: 1, F: 1 }, effect: "none" },
{ name: "氟化鋁", formula: { Al: 1,F: 3 }, effect: "none" },
{ name: "氟化鋰", formula: { Li: 1, F: 1 }, effect: "none" },
{ name: "氟化鎂", formula: { Mg: 1, F: 2 }, effect: "none" },
{ name: "氧化鈉", formula: { Na: 2, O: 1 }, effect: "none" },
{ name: "氧化鈣", formula: { Ca: 1, O: 1 }, effect: "none" },
{ name: "氧化鈹", formula: { Be: 1, O: 1 }, effect: "none" },
{ name: "氧化鉀", formula: { K: 2, O: 1 }, effect: "none" },
{ name: "氧化鋁", formula: { Al: 2, O: 3 }, effect: "none" },
{ name: "氧化鋰", formula: { Li: 2, O: 1 }, effect: "none" },
{ name: "氧化鎂", formula: { Mg: 1, O: 1 }, effect: "none" },
{ name: "氧氣", formula: { O: 2 }, effect: "none" },
{ name: "臭氧", formula: { O: 3 }, effect: "poison" },
{ name: "氫氟酸", formula: { H: 1, F: 1 }, effect: "corrosion" },
{ name: "氫氣", formula: { H: 2 }, effect: "none" },
{ name: "氫氧化鈉", formula:{Na:1,O:1,H:1}, effect:"corrosion" },
{ name: "氫氧化鈣", formula: { Ca: 1, O: 2, H: 2 }, effect: "corrosion" },
{ name: "氫氧化鉀", formula: { K: 1, O: 1, H: 1 }, effect: "corrosion" },
{ name: "氫氧化鋁", formula: { Al: 1, O: 3, H: 3 }, effect: "none" },
{ name: "氫氧化鋰", formula: { Li: 1, O: 1, H: 1 }, effect: "corrosion" },
{ name: "氫氧化鎂", formula: { Mg: 1, O: 2, H: 2 }, effect: "none" },
{ name: "氮化鈉", formula: { Na: 3, N: 1 }, effect: "none" },
{ name: "氮化鉀", formula: { K: 3, N: 1 }, effect: "none" },
{ name: "氮化鋁", formula: { Al: 1, N: 1 }, effect: "none" },
{ name: "氮化鋰", formula: { Li: 3, N: 1 }, effect: "none" },
{ name: "氮氣", formula: { N: 2 }, effect: "none" },
{ name: "氯化鈉", formula:{Na:1,Cl:1}, effect:"none" },
{ name: "氯化鈹", formula: { Be: 1, Cl: 2 }, effect: "none" },
{ name: "氯化鉀", formula: { K: 1, Cl: 1 }, effect: "none" },
{ name: "氯化鋁", formula: { Al: 1, Cl: 3 }, effect: "none" },
{ name: "氯化鋰", formula: { Li: 1, Cl: 1 }, effect: "none" },
{ name: "氯化鎂", formula: { Mg: 1, Cl: 2 }, effect: "none" },
{ name: "氯仿", formula:{C:1,H:1,Cl:3}, effect:"poison" },
{ name: "氯氣", formula: { Cl: 2 }, effect: "poison" },
{ name: "氰酸", formula:{H:1,C:1,N:1,O:1}, effect:"poison" },
{ name: "硝酸", formula:{H:1,N:1,O:3}, effect:"corrosion" },
{ name: "硫化鈉", formula: { Na: 2, S: 1 }, effect: "none" },
{ name: "硫化鈹", formula: { Be: 1, S: 1 }, effect: "none" },
{ name: "硫化鉀", formula: { K: 2, S: 1 }, effect: "none" },
{ name: "硫化鋁", formula: { Al: 2, S: 3 }, effect: "none" },
{ name: "硫化鋰", formula: { Li: 2, S: 1 }, effect: "none" },
{ name: "硫化鎂", formula: { Mg: 1, S: 1 }, effect: "none" },
{ name: "硫酸", formula:{H:2,S:1,O:4}, effect:"corrosion" },
{ name: "溴化鈉", formula: { Na: 1, Br: 1 }, effect: "none" },
{ name: "溴化鉀", formula: { K: 1, Br: 1 }, effect: "none" },
{ name: "溴化鋰", formula: { Li: 1, Br: 1 }, effect: "none" },
{ name: "溴化鎂", formula: { Mg: 1, Br: 2 }, effect: "none" },
{ name: "碘化鈉", formula: { Na: 1, I: 1 }, effect: "none" },
{ name: "碘化鉀", formula: { K: 1, I: 1 }, effect: "none" },
{ name: "碳化矽", formula: { C: 1, Si: 1 }, effect: "poison" },
{ name: "磷化鈉", formula: { Na: 3, P: 1 }, effect: "none" },
{ name: "磷化鉀", formula: { K: 3, P: 1 }, effect: "none" },
{ name: "磷化鋁", formula: { Al: 1, P: 1 }, effect: "none" },
{ name: "磷化鋰", formula: { Li: 3, P: 1 }, effect: "none" },
{ name: "鹽酸", formula:{H:1,Cl:1}, effect:"corrosion" }

    ];
    function findMol(sel){
      const cnt={}; sel.forEach(c=>c&&c.el&&(cnt[c.el]=(cnt[c.el]||0)+1));
      for(const m of MOLECULES){ const f=m.formula;
        if(Object.values(f).reduce((a,b)=>a+b,0)!==sel.length) continue;
        let ok=true; for(const k in f) if(cnt[k]!==f[k]) ok=false;
        for(const k in cnt) if(!f[k]) ok=false;
        if(ok) return m;
      }
      return null;
    }
    function showToast(msg){const t=document.getElementById('toast');t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),2000);}
    function App(){
      // 回復配置：分子即時與每回合回血
      const RECOVER_CONFIG = {
        '水': { immediate: 7, perTurn: 1 },
        // 如需其他分子回血，可在此新增
      };
      // 通用回血觸發函式
      const triggerRecovery = (target, molName, trigger) => {
        const cfg = RECOVER_CONFIG[molName];
        if (!cfg || !cfg[trigger]) return;
        const heal = cfg[trigger];
        const setter = target === 'player' ? setP : setA;
        setter(hp => Math.min(MAX_HP, hp + heal));
        addLog(`${molName}${trigger==='immediate'? ' 合成回復':' 每回合回復'} ${heal} HP`);
      };

      // 其餘狀態鉤子與函式...
      const [turn,setTurn]=React.useState('player');
      const [pHP,setP]=React.useState(MAX_HP);
      const [aHP,setA]=React.useState(MAX_HP);
      const [pHand,setPH]=React.useState([]);
      const [aHand,setAH]=React.useState([]);
      const [pField,setPF]=React.useState([]);
      const [aField,setAF]=React.useState([]);
      const [selEls,setSelEls]=React.useState([]);
      const [selMol,setSelMol]=React.useState(null);
      const [log,setLog]=React.useState([]);
      const [gameOver,setGameOver]=React.useState(null);
      const firstDraw=React.useRef(true);
      const addLog=msg=>setLog(l=>[msg,...l]);
      const resetGame=()=>{setP(MAX_HP);setA(MAX_HP);setPH(Array.from({length:5},drawCard));setAH(Array.from({length:5},drawCard));setPF([]);setAF([]);setSelEls([]);setSelMol(null);setLog([]);setGameOver(null);setTurn('player');firstDraw.current=true;addLog('遊戲重置，玩家先手');};
      React.useEffect(()=>resetGame(),[]);
      React.useEffect(()=>{if(gameOver) return; if(firstDraw.current){firstDraw.current=false;return;} if(turn==='player'){setPH(h=>[...h,drawCard(),drawCard()]);addLog('玩家抽2張');
          // 水分子每回合回復
          const waterCount = pField.filter(m => m.name==='水').length;
          if(waterCount>0){
            const heal = waterCount * RECOVER_CONFIG['水'].perTurn;
            setP(h=>Math.min(MAX_HP, h + heal));
            addLog(`每回合回復 ${heal} HP`);
          }}else{setAH(h=>[...h,drawCard(),drawCard()]);addLog('AI抽2張');}},[turn,gameOver]);
      React.useEffect(()=>{if(pHP<=0)setGameOver('lose');else if(aHP<=0)setGameOver('win');},[pHP,aHP]);  
      const applyDamage=(target,dmg)=>{let field=target==='player'?pField:aField;const setField=target==='player'?setPF:setAF;const setHp=target==='player'?setP:setA;const idx=field.findIndex(c=>c.usable);if(idx>=0){const card=field[idx];const block=ELEMENTS.indexOf(card.el)+1;showToast(`惰性氣體阻擋 ${block} 點傷害`);dmg=Math.max(0,dmg-block);setField(f=>f.filter((_,i)=>i!==idx));}setHp(h=>Math.max(0,h-dmg));};  
      const handleCombine = () => {
        if (turn !== 'player' || gameOver) return;
        if (selEls.length < 2) { showToast('請至少選2張'); return; }
        const cards = selEls.map(i => pHand[i]);
        if (cards.some(c => c.corroded)) { showToast('腐蝕卡無法合成'); return; }
        const m = findMol(cards);
        if (!m) { showToast('無法合成'); return; }
        // 合成分子
        setPF(f => [m, ...f]);
        setPH(h => h.filter((_, i) => !selEls.includes(i)));
        addLog(`合成 ${m.name}`);
        // 傷害計算
        const dmg = selEls.reduce((s, i) => s + (ELEMENTS.indexOf(pHand[i].el) + 1), 0);
        applyDamage('ai', dmg);
        // 合成水時立即回血
        if (m.name === '水') {
          triggerRecovery('player', '水', 'immediate');
          showToast(`合成水，回復 ${RECOVER_CONFIG['水'].immediate} HP`);
        }
        setSelEls([]);
      };  
      const handleDiscard=()=>{if(turn!=='player'||gameOver)return; if(selEls.length<1){showToast('請選擇要棄牌');return;}if(selEls.length>3){showToast('最多棄牌三張');return;}const names=selEls.map(i=>pHand[i].el).join(',');setPH(h=>h.filter((_,i)=>!selEls.includes(i)));addLog(`棄牌: ${names}`);setSelEls([]);handleEnd();};  
      const handleEnd=()=>{if(gameOver)return;setSelEls([]);setSelMol(null);setTurn(t=>t==='player'?'ai':'player');addLog('結束回合');};  
      const handleSelectEl=i=>{if(gameOver||turn!=='player')return;setSelMol(null);setSelEls(s=>s.includes(i)?s.filter(x=>x!==i):[...s,i]);};  
      const handleSelectMol=i=>{if(gameOver||turn!=='player')return;setSelEls([]);setSelMol(selMol===i?null:i);};  
      const hasWater = pField.some(m => m.name === '水') || aField.some(m => m.name === '水');
      const canUse = (turn === 'player' && !gameOver) && (
        (selMol !== null && pField[selMol].effect !== 'none') ||
        (selEls.length === 1 && (
          pHand[selEls[0]].usable ||
          (ALKALI.includes(pHand[selEls[0]].el) && hasWater)
        ))
      );  
      const handleUse = () => {
        if (turn !== 'player' || gameOver) return;
        if (selMol !== null) {
          const m = pField[selMol];
          addLog(`使用 分子 ${m.name}`);
          const dmg = Object.entries(m.formula || {}).reduce(
            (s, [el, n]) => s + (ELEMENTS.indexOf(el) + 1) * n,
            0
          );
          applyDamage('ai', dmg);
          setPF((f) => f.filter((_, i) => i !== selMol));
          setSelMol(null);
        } else if (selEls.length === 1) {
          const idx = selEls[0];
          const card = pHand[idx];
          // 惰性氣體
          if (card.usable) {
            setPF((f) => [{ el: card.el, usable: true }, ...f]);
            addLog(`使用 惰性氣體 ${card.el}`);
            setPH((h) => h.filter((_, i) => i !== idx));
          }
          // 1A族引爆水
          else if (ALKALI.includes(card.el) && hasWater) {
            const waterCount = [...pField, ...aField].filter((mol) => mol.name === '水').length;
            const atomNum = ELEMENTS.indexOf(card.el) + 1;
            const waterMol = MOLECULES.find((m) => m.name === '水');
            const waterAtomNum = Object.entries(waterMol.formula).reduce((s, [el, n]) => s + (ELEMENTS.indexOf(el) + 1) * n, 0);
            const dmg = (atomNum + waterAtomNum) * waterCount;
            showToast(`實驗室爆炸了！造成${dmg}點傷害`);
            addLog(`實驗室爆炸了！造成${dmg}點傷害`);
            applyDamage('ai', dmg);
            // 消耗使用的元素牌
            setPH((h) => h.filter((_, i) => i !== idx));
            // 產生對應鹼性分子並移除所有水分子
            const newMolName = card.el === 'Li' ? '氫氧化鋰' : card.el === 'Na' ? '氫氧化鈉' : '氫氧化鉀';
            const newMol = MOLECULES.find((m) => m.name === newMolName);
            setPF((f) => [newMol, ...f.filter((mol) => mol.name !== '水')] );
            setAF((f) => f.filter((mol) => mol.name !== '水'));((f) => f.filter((mol) => mol.name !== '水'));
          } else {
            // 其他元素使用
            addLog(`使用 元素 ${card.el}`);
            setPH((h) => h.filter((_, i) => i !== idx));
          }
          setSelEls([]);
        }
        // 結束玩家回合
        setTurn('ai');
      };  
      React.useEffect(()=>{if(gameOver||turn!=='ai')return;setTimeout(()=>{let hand=[...aHand];let field=[...aField];const sumAtoms=f=>Object.entries(f).reduce((s,[el,n])=>s+(ELEMENTS.indexOf(el)+1)*n,0);const tryAction=()=>{const possible=MOLECULES.filter(m=>{const cnt={};hand.forEach(c=>cnt[c.el]=(cnt[c.el]||0)+1);return Object.entries(m.formula||{}).every(([el,n])=>cnt[el]>=n);});if(possible.length>0){if(Math.random()<0.3){addLog('AI 選擇結束回合');return;}possible.sort((a,b)=>sumAtoms(b.formula)-sumAtoms(a.formula));const m=possible[0];const used=[];Object.entries(m.formula).forEach(([el,n])=>{for(let i=hand.length-1;i>=0&&n>0;i--)if(hand[i].el===el){used.push(el);hand.splice(i,1);n--;}});setAF(f=>[m,...f]);addLog(`AI 合成 ${m.name}`);const dmg=used.reduce((s,el)=>s+(ELEMENTS.indexOf(el)+1),0);applyDamage('player',dmg);addLog(`玩家受 ${dmg} 傷`);tryAction();}else{if(Math.random()<0.5){addLog('AI 選擇結束回合');}else{let toDiscard=hand.length>8?3:hand.length>5?2:1;const idxs=[];while(idxs.length<toDiscard&&hand.length>0){const i=Math.floor(Math.random()*hand.length);if(!idxs.includes(i))idxs.push(i);}const names=idxs.map(i=>hand[i].el).join(',');idxs.sort((a,b)=>b-a).forEach(i=>hand.splice(i,1));setAH([...hand]);addLog(`AI 棄牌: ${names}`);} } };tryAction();handleEnd();},2000);},[turn,gameOver]);  
      const possibleList=React.useMemo(()=>{const cnt={};pHand.forEach(c=>cnt[c.el]=(cnt[c.el]||0)+1);return MOLECULES.filter(m=>Object.entries(m.formula||{}).every(([el,n])=>cnt[el]>=n)).map(m=>`${m.name} (${Object.entries(m.formula).map(([el,n])=>n>1?`${n}${el}`:el).join(' + ')})`);},[pHand]);  
 
      return(<div className="game-container"><div className="board">
        <h1>真實煉金：化合之戰</h1>
        <img src="https://wen91027.github.io/img/background_logo.jpeg" alt="遊戲首圖" className="bg-logo" />


        {gameOver&&<div className="overlay"><h2>{gameOver==='win'?'你贏了':'化學不會就是不會'}</h2><button onClick={resetGame}>重新開始</button></div>}
        <div className="hp-section"><span className="hp-label">AI HP</span><div className="hp-bar"><div className="hp-inner" style={{width:`${aHP/MAX_HP*100}%`}}/></div><span>{aHP}</span></div>
        <div className="zone"><div className="zone-title">對手分子區</div><div className="field">{aField.map((c,i)=>
          <div key={i} className={`card molecule ${c.effect} ${c.usable?'inert':''}`}>
            <div className="symbol">{c.usable?c.el:c.name}</div>
            {c.usable&&<div className="block-info">阻擋{ELEMENTS.indexOf(c.el)+1}傷害</div>}
             {c.effect === 'recover' &&
          <div className="recover-info">
            持續回復{RECOVER_CONFIG['水'].perTurn}HP
          </div>
        }
          </div>
        )}</div></div>
        <div className="log">{log.slice(0,5).map((l,i)=>
          <div key={i} style={{color:i===0?'#ff0':'#ccc'}}>{l}</div>
        )}</div>
        <div className="zone"><div className="zone-title">我方分子區</div><div className="field">{pField.map((c,i)=>
          <div key={i} className={`card molecule ${c.effect} ${c.usable?'inert':''}${selMol===i?' selected':''}`} onClick={()=>handleSelectMol(i)}>
            {c.usable
              ? React.createElement(React.Fragment, null,
                  React.createElement("div", { className: "symbol" }, c.el),
                  React.createElement("div", { className: "block-info" }, `阻擋${ELEMENTS.indexOf(c.el)+1}傷害`)
                )
              : React.createElement("div", { className: "name" }, c.name)
            }
                    {c.effect === 'recover' &&
          <div className="recover-info">
            持續回復{RECOVER_CONFIG['水'].perTurn}HP
          </div>
        }
            
          </div>
        )}</div></div>
             <div className="hp-section"><span className="hp-label">玩家 HP</span><div className="hp-bar"><div className="hp-inner" style={{width:`${pHP/MAX_HP*100}%`}}/></div><span>{pHP}</span></div>

        <div className="zone"><div className="zone-title">玩家手牌</div><div className="hand">{pHand.map((c,i)=>
          <div key={i}
               className={`card element ${c.usable?'inert':''}${ALKALI.includes(c.el)?' alkali':''}${selEls.includes(i)?' selected':''}`}
               onClick={()=>handleSelectEl(i)}>
            <div className="symbol">{c.el}</div>
            <div className="number">{ELEMENTS.indexOf(c.el)+1}</div>
            {c.usable&&<div className="defense">防禦傷害</div>}
            {ALKALI.includes(c.el)&&<div className="explode">引爆水</div>}
          </div>
        )}</div></div>
        <div className="prompt">{possibleList.length>0?`可合成: ${possibleList.join('、')}`:'無可合成化合物'}</div>
        <div className="controls"><button onClick={handleCombine} disabled={turn!=='player'||gameOver||selEls.length<2}>合成</button><button onClick={handleUse} disabled={!canUse}>使用</button><button onClick={handleDiscard} disabled={turn!=='player'||gameOver||selEls.length<1}>棄牌</button><button onClick={handleEnd} disabled={turn!=='player'||gameOver}>結束回合</button></div>
         </div></div>);
    }
    ReactDOM.render(<App/>,document.getElementById('root'));
  </script>
</body>
</html>
