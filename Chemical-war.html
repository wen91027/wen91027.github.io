<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>çœŸå¯¦ç…‰é‡‘ï¼šåŒ–åˆä¹‹æˆ°</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400&display=swap" rel="stylesheet" />
  <style>
    body { margin:0; background:#0d1321; color:#fff; font-family:'Orbitron',sans-serif; text-align:center; }
    .toast { position:fixed; top:150px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); color:#f55; padding:8px 16px; border:1px solid #f55; border-radius:4px; z-index:2000; opacity:0; transition:opacity 0.3s; }
    .toast.show { opacity:1; }
    .game-container { display:flex; flex-direction:column; align-items:center; padding:1em; }
    .board { width:90%; max-width:800px; background:#1a242f; border:2px solid #444; border-radius:10px; padding:1em; position:relative; }
    .overlay { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:1000; }
    .overlay button { margin-top:1em; }
    .hp-section { display:flex; align-items:center; justify-content:center; margin:8px 0; }
    .hp-label { margin-right:8px; }
    .hp-bar { flex:1; background:#222; border:1px solid #0ff; border-radius:4px; height:16px; margin:0 8px; overflow:hidden; }
    .hp-inner { background:#0ff; height:100%; }
    .zone { margin:12px 0; }
    .zone-title { color:#ccc; margin-bottom:4px; }
    .hand { display:flex; flex-wrap:wrap; justify-content:center; }
    .field { display:flex; flex-wrap:nowrap; justify-content:flex-start; overflow-x:auto; }
    .card { border:1px solid #555; border-radius:6px; padding:6px; margin:4px; transition:transform .2s; display:flex; flex-direction:column; align-items:center; }
    .card:hover { transform:translateY(-4px); }
    .card.element { width:50px; height:70px; background:#1f2a36; cursor:pointer; position:relative; }
    .card.element.inert { background:#555; }
    .card.element.alkali { background:#a00; }
    .card.element .symbol {  font-size: 1.2em;
  margin-top: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex: 1; /* è®“å®ƒæ’æ»¿çˆ¶å…ƒç´ é«˜åº¦ï¼Œä¾¿æ–¼ç½®ä¸­ */}
    .card.element .number { position:absolute; top:4px; right:6px; font-size:0.8em; color:#0ff; }
    .card.element .defense { position:absolute; bottom:4px; width:100%; font-size:0.6em; color:#fff; text-align:center; }
    .card.element .explode { position:absolute; bottom:4px; width:100%; font-size:0.6em; color:#ff0; text-align:center; }
    .card.element.selected { border-color:#0f0; box-shadow:0 0 6px #0f0; }
    .card.element.corroded { background: linear-gradient(45deg, #555 25%, #333 25%, #333 50%, #555 50%, #555 75%, #333 75%, #333 100%); background-size: 6px 6px;position: relative;}
    .card.element.corroded::after {content: "è…è•";position: absolute;top: 2px;left: 50%;transform: translateX(-50%);font-size: 0.4em;color: #ff6688;}
    
    .card.molecule { width:80px; min-height:60px; background:#14232e; cursor:pointer; position:relative; }
    /* effect-specific backgrounds */
    .card.molecule.corrosion { background:#661100; }
    .card.molecule.poison    { background:#440066; }
    .card.molecule.burn      { background:#663300; }
    .card.molecule.recover   { background:#00AEAE; border:2px solid #fff; box-shadow:0 0 8px #fff;}
    .card.molecule.inert     { background:#555; border:2px solid #fff; box-shadow:0 0 8px #fff; pointer-events:none; display:flex; flex-direction:column; justify-content:center; align-items:center; }
    .card.molecule.inert .symbol    { font-size:1em; margin:4px 0; }
    .card.molecule.inert .block-info { font-size:0.8em; color:#fff; }
    .card.molecule.recover .symbol     { font-size:1em; margin-top:8px; }
    .card.molecule.recover .recover-info { position:absolute; bottom:4px; width:100%; font-size:0.6em; color:#fff; text-align:center; }
    .card.molecule.acid {  background: #BF0060;}
    .card.molecule.corrosion .corrosion-info {
  position: absolute;
  bottom: 4px;
  width: 100%;
  font-size: 0.6em;
  color: #ff6688; /* æ¯”è¼ƒåç²‰ç´…ç´…è‰² */
  text-align: center;
  font-weight: bold;
}
    
    .card.molecule.selected { border:2px solid #0f0; box-shadow:0 0 6px #0f0; }
    .controls { margin:8px 0; }
    button { font-family:'Orbitron',sans-serif; background:#112233; color:#0ff; border:1px solid #0ff; border-radius:4px; padding:6px 12px; margin:0 4px; cursor:pointer; transition:background 0.2s; }
    button:hover:enabled { background:#334455; }
    button:disabled { opacity:0.5; cursor:not-allowed; }
    .prompt { color:#8cf; margin-top:4px; }
    .log { text-align:center; max-height:120px; overflow-y:auto; background:#112233; padding:8px; border:1px solid #333; border-radius:4px; margin-top:8px; font-size:1em; }
    .enemy-hand .card { opacity: 0.6;  pointer-events: none;}
    @media (orientation: portrait) {
    .board { width:100%; padding:0.5em; }
    .hp-section { flex-direction: column; }
    .hp-label, .hp-text { margin: 2px 0; }
    .hp-bar { flex: none !important; width: 100% !important; margin: 4px 0; }
    .zone-title { font-size: 0.9em; }
    .hand { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 0.25em; }
    .field { display: flex; flex-wrap: nowrap; overflow-x: auto; padding-bottom: 4px; }
    .card { margin: 2px; padding: 4px; min-width: 60px; }
    .card.element { width: auto; height: 60px; }
    .card.molecule { width: auto; min-height: 50px; }
    button { width: 100%; margin: 4px 0; padding: 8px; }
    .controls { flex-direction: column; }
    .prompt, .log { font-size: 0.8em; }
  }
    .hp-section { flex-direction: column; }
    .hp-label, .hp-text { margin: 2px 0; }
    .hp-bar { flex: none !important; width: 100% !important; margin: 4px 0; }
    .zone-title { font-size: 0.9em; }
    .hand, .field { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 0.25em; }
    .card { margin: 2px; padding: 4px; min-width: 60px; }
    .card.element { width: auto; height: 60px; }
    .card.molecule { width: auto; min-height: 50px; }
    button { width: 100%; margin: 4px 0; padding: 8px; }
    .controls { flex-direction: column; }
    .prompt, .log { font-size: 0.8em; }
    .bg-logo {
  width: 100%;
  max-width: 100%;
  height: auto;
  display: block;
  margin: 0 auto 1em;
}

   /* å‹•ç•«æ•ˆæœæ–°å¢åœ¨é€™ */

    /* AIæ€è€ƒé®ç½© */
.ai-text {font-size: 1.5em;color: #0ff;animation: pulse 1s infinite;text-shadow: 0 0 10px #0ff;}

@keyframes pulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.6; }
  100% { transform: scale(1); opacity: 1; }
}

/* ç‰Œå¾ä¸Šå¾€ä¸‹é£›ä¸¦æ·¡å…¥ */
    
@keyframes slide-down {
  0% {transform: translateY(-100px);opacity: 0;}
  100% {transform: translateY(0);opacity: 1;}
}
/* å‰›åˆæˆçš„ç‰Œ */
.card.molecule.newly-created { animation: slide-down 0.6s ease-out;}
/* æ–°çš„é£›å…¥å‹•ç•« */
@keyframes fly-in {
  0% {
    transform: translateY(-80px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
}

 /* åˆæˆå‹•ç•«ï¼šåˆ†å­ */
.card.molecule.just-combined {
  animation: fly-in 0.5s ease-out;
  z-index: 10;
}

/* æŠ½å¡å‹•ç•«ï¼šå…ƒç´  */
.card.element.just-drawn {
  animation: fly-in 0.5s ease-out;
  z-index: 10;
}
/* åˆæˆå‹•ç•«ï¼šå…ƒç´  */
    .card.element.combine-out {
  animation: combine-out 0.5s ease-in-out forwards;
}

@keyframes combine-out {
  0%   { transform: scale(1) translateY(0); opacity: 1; }
  100% { transform: scale(0.2) translateY(-40px); opacity: 0; }
}

/* åˆæˆå‹•ç•«ï¼šç‰¹æ•ˆå…‰ */
    
.card.molecule.flash {
  position: relative;
}

.card.molecule.flash::after {
  content: "";
  position: absolute;
  top: -6px;
  left: -6px;
  width: calc(100% + 12px);
  height: calc(100% + 12px);
  border-radius: 10px;
  border: 2px solid rgba(255, 255, 255, 0.8);
  animation: flash-glow 0.8s ease-out;
  pointer-events: none;
  z-index: 999;
}

@keyframes flash-glow {
  0% { box-shadow: 0 0 0px #fff; transform: scale(1); }
  50% { box-shadow: 0 0 20px #fff; transform: scale(1.05); }
  100% { box-shadow: 0 0 0px #fff; transform: scale(1); }
  z-index: 999;
}

    .card.molecule.newly-created {
  animation: flash-glow 0.6s ease-out;
      z-index: 999;
}
    
  }
  </style>
  
      </head>
<body>
  <div id="toast" class="toast"></div>
  <div id="root"></div>
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <script type="text/babel">
    const MAX_HP = 128;
    const ELEMENTS = ["H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca"];
    const ALKALI = ["Li","Na","K"]; // 1Aæ—
    const METALS = ["Li", "Na", "K", "Be", "Mg", "Ca", "Al"]; // é‡‘å±¬å…ƒç´ 
    const WEIGHTS = {H:16,C:10,O:12,N:8,Na:5,He:2,Ne:1,Ar:0.5};
    const drawPool = [];
    ELEMENTS.forEach(e => {
      const w = WEIGHTS[e]||3;
      for (let i=0;i<Math.round(w*2);i++) drawPool.push(e);
    });
    function drawCard(){
      const el = drawPool[Math.floor(Math.random()*drawPool.length)];
      return { el, corroded:false, usable:['He','Ne','Ar'].includes(el) };
    }
    const MOLECULES = [
      { name: "ä¸€æ°§åŒ–æ°®",  formula: { N: 1, O: 1 },        kind: "none",         effect: "poison"     },
  { name: "ä¸€æ°§åŒ–ç¢³",  formula: { C: 1, O: 1 },        kind: "none",         effect: "poison"     },
  { name: "ä¹™ç‚”",      formula: { C: 2, H: 2 },        kind: "organic",      effect: "burn"       },
  { name: "ä¹™çƒ¯",      formula: { C: 2, H: 4 },        kind: "organic",      effect: "burn"       },
  { name: "äºŒæ°§åŒ–ç¢³",  formula: { C: 1, O: 2 },        kind: "none",         effect: "none"       },
  { name: "æ°´",        formula: { H: 2, O: 1 },        kind: "none",         effect: "recover"    },
  { name: "ç”²çƒ·",      formula: { C: 1, H: 4 },        kind: "organic",      effect: "burn"       },
  { name: "å…‰æ°£",      formula: { C: 1, O: 1, Cl: 2 }, kind: "organic",      effect: "poison"     },
  { name: "æ°ŸåŒ–éˆ‰",    formula: { Na: 1, F: 1 },       kind: "salt",         effect: "none"       },
  { name: "æ°ŸåŒ–éˆ¹",    formula: { Be: 1, F: 2 },       kind: "salt",         effect: "none"       },
  { name: "æ°ŸåŒ–é‰€",    formula: { K: 1, F: 1 },        kind: "salt",         effect: "none"       },
  { name: "æ°ŸåŒ–é‹",    formula: { Al: 1, F: 3 },       kind: "salt",         effect: "none"       },
  { name: "æ°ŸåŒ–é‹°",    formula: { Li: 1, F: 1 },       kind: "salt",         effect: "none"       },
  { name: "æ°ŸåŒ–é‚",    formula: { Mg: 1, F: 2 },       kind: "salt",         effect: "none"       },
  { name: "æ°§åŒ–éˆ‰",    formula: { Na: 2, O: 1 },       kind: "salt",         effect: "none"       },
  { name: "æ°§åŒ–éˆ£",    formula: { Ca: 1, O: 1 },       kind: "salt",         effect: "none"       },
  { name: "æ°§åŒ–éˆ¹",    formula: { Be: 1, O: 1 },       kind: "salt",         effect: "none"       },
  { name: "æ°§åŒ–é‰€",    formula: { K: 2, O: 1 },        kind: "salt",         effect: "none"       },
  { name: "æ°§åŒ–é‹",    formula: { Al: 2, O: 3 },       kind: "salt",         effect: "none"       },
  { name: "æ°§åŒ–é‹°",    formula: { Li: 2, O: 1 },       kind: "salt",         effect: "none"       },
  { name: "æ°§åŒ–é‚",    formula: { Mg: 1, O: 1 },       kind: "salt",         effect: "none"       },
  { name: "æ°§æ°£",      formula: { O: 2 },             kind: "none",         effect: "none"       },
  { name: "è‡­æ°§",      formula: { O: 3 },             kind: "none",         effect: "poison"     },
  { name: "æ°«æ°Ÿé…¸",    formula: { H: 1, F: 1 },       kind: "strong_acid",  effect: "corrosion" },
  { name: "æ°«æ°£",      formula: { H: 2 },             kind: "none",         effect: "none"       },
  { name: "æ°«æ°§åŒ–éˆ‰",  formula: { Na: 1, O: 1, H: 1},  kind: "strong_base", effect: "alkali"    },
  { name: "æ°«æ°§åŒ–éˆ£",  formula: { Ca: 1, O: 2, H: 2},  kind: "base",        effect: "alkali"    },
  { name: "æ°«æ°§åŒ–é‰€",  formula: { K: 1, O: 1, H: 1},  kind: "strong_base", effect: "alkali"    },
  { name: "æ°«æ°§åŒ–é‹",  formula: { Al: 1, O: 3, H: 3},  kind: "none",         effect: "none"       },
  { name: "æ°«æ°§åŒ–é‹°",  formula: { Li: 1, O: 1, H: 1},  kind: "strong_base", effect: "alkali"    },
  { name: "æ°«æ°§åŒ–é‚",  formula: { Mg: 1, O: 2, H: 2},  kind: "base",        effect: "alkali"    },
  { name: "æ°®åŒ–éˆ‰",    formula: { Na: 3, N: 1 },       kind: "salt",         effect: "none"       },
  { name: "æ°®åŒ–é‰€",    formula: { K: 3, N: 1 },        kind: "salt",         effect: "none"       },
  { name: "æ°®åŒ–é‹",    formula: { Al: 1, N: 1 },       kind: "salt",         effect: "none"       },
  { name: "æ°®åŒ–é‹°",    formula: { Li: 3, N: 1 },       kind: "salt",         effect: "none"       },
  { name: "æ°®æ°£",      formula: { N: 2 },             kind: "none",         effect: "none"       },
  { name: "æ°¯åŒ–éˆ‰",    formula: { Na: 1, Cl: 1 },      kind: "salt",         effect: "none"       },
  { name: "æ°¯åŒ–éˆ¹",    formula: { Be: 1, Cl: 2 },      kind: "salt",         effect: "none"       },
  { name: "æ°¯åŒ–é‰€",    formula: { K: 1, Cl: 1 },       kind: "salt",         effect: "none"       },
  { name: "æ°¯åŒ–é‹",    formula: { Al: 1, Cl: 3 },      kind: "salt",         effect: "none"       },
  { name: "æ°¯åŒ–é‹°",    formula: { Li: 1, Cl: 1 },      kind: "salt",         effect: "none"       },
  { name: "æ°¯åŒ–é‚",    formula: { Mg: 1, Cl: 2 },      kind: "salt",         effect: "none"       },
  { name: "æ°¯ä»¿",      formula: { C: 1, H: 1, Cl: 3},  kind: "organic",      effect: "poison"     },
  { name: "æ°¯æ°£",      formula: { Cl: 2 },            kind: "none",         effect: "poison"     },
  { name: "æ°°é…¸",      formula: { H: 1, C: 1, N: 1, O: 1}, kind: "acid",      effect: "corrosion" },
  { name: "ç¡é…¸",      formula: { H: 1, N: 1, O: 3},  kind: "strong_acid", effect: "corrosion" },
  { name: "ç¡«åŒ–éˆ‰",    formula: { Na: 2, S: 1 },       kind: "salt",         effect: "none"       },
  { name: "ç¡«åŒ–éˆ¹",    formula: { Be: 1, S: 1 },       kind: "salt",         effect: "none"       },
  { name: "ç¡«åŒ–é‰€",    formula: { K: 2, S: 1 },        kind: "salt",         effect: "none"       },
  { name: "ç¡«åŒ–é‹",    formula: { Al: 2, S: 3 },       kind: "salt",         effect: "none"       },
  { name: "ç¡«åŒ–é‹°",    formula: { Li: 2, S: 1 },       kind: "salt",         effect: "none"       },
  { name: "ç¡«åŒ–é‚",    formula: { Mg: 1, S: 1 },       kind: "salt",         effect: "none"       },
  { name: "ç¡«é…¸",      formula: { H: 2, S: 1, O: 4},  kind: "strong_acid", effect: "corrosion" },
  { name: "æº´åŒ–éˆ‰",    formula: { Na: 1, Br: 1 },      kind: "salt",         effect: "none"       },
  { name: "æº´åŒ–é‰€",    formula: { K: 1, Br: 1 },       kind: "salt",         effect: "none"       },
  { name: "æº´åŒ–é‹°",    formula: { Li: 1, Br: 1 },      kind: "salt",         effect: "none"       },
  { name: "æº´åŒ–é‚",    formula: { Mg: 1, Br: 2 },      kind: "salt",         effect: "none"       },
  { name: "ç¢˜åŒ–éˆ‰",    formula: { Na: 1, I: 1 },       kind: "salt",         effect: "none"       },
  { name: "ç¢˜åŒ–é‰€",    formula: { K: 1, I: 1 },        kind: "salt",         effect: "none"       },
  { name: "ç¢³åŒ–çŸ½",    formula: { C: 1, Si: 1 },       kind: "none",         effect: "poison"     },
  { name: "ç£·åŒ–éˆ‰",    formula: { Na: 3, P: 1 },       kind: "salt",         effect: "none"       },
  { name: "ç£·åŒ–é‰€",    formula: { K: 3, P: 1 },        kind: "salt",         effect: "none"       },
  { name: "ç£·åŒ–é‹",    formula: { Al: 1, P: 1 },       kind: "salt",         effect: "none"       },
  { name: "ç£·åŒ–é‹°",    formula: { Li: 3, P: 1 },       kind: "salt",         effect: "none"       },
  { name: "é¹½é…¸",      formula: { H: 1, Cl: 1 },      kind: "strong_acid",  effect: "corrosion" }
    ];
    function findMol(sel){
      const cnt={}; sel.forEach(c=>c&&c.el&&(cnt[c.el]=(cnt[c.el]||0)+1));
      for(const m of MOLECULES){ const f=m.formula;
        if(Object.values(f).reduce((a,b)=>a+b,0)!==sel.length) continue;
        let ok=true; for(const k in f) if(cnt[k]!==f[k]) ok=false;
        for(const k in cnt) if(!f[k]) ok=false;
        if(ok) return m;
      }
      return null;
    }

    
//è…è•ç›¸é—œå‡½å¼
function corrodeMetals(hand, setHand, count = 2) {  // <--- åŠ ä¸€å€‹ count = 2 é è¨­
  const metals = METALS;
  const metalIndices = hand
    .map((c, i) => (metals.includes(c.el) && !c.corroded ? i : -1))
    .filter(i => i !== -1);

  if (metalIndices.length > 0) {
    const shuffle = [...metalIndices].sort(() => Math.random() - 0.5);
    const selected = shuffle.slice(0, Math.min(count, shuffle.length));
    const newHand = [...hand];
    selected.forEach(i => newHand[i] = { ...newHand[i], corroded: true });
    setHand(newHand);
    return selected.length;
  }
  return 0;
}
//æ¸…é™¤è…è•
    function clearCorrosion(hand, setHand) {
  const newHand = hand.map(c => c.corroded ? { ...c, corroded: false } : c);
  setHand(newHand);
}
    
    function showToast(msg){const t=document.getElementById('toast');t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),2000);}
    
  

    //APP ä¸»è¦éŠæˆ²æ®µè½-----------------------------------------------
    function App(){

        // å…¶é¤˜ç‹€æ…‹é‰¤å­èˆ‡å‡½å¼...
      const [turn,setTurn]=React.useState('player');
      const [pHP,setP]=React.useState(MAX_HP);
      const [aHP,setA]=React.useState(MAX_HP);
      const [pHand,setPH]=React.useState([]);
      const [aHand,setAH]=React.useState([]);
      const [pField,setPF]=React.useState([]);
      const [aField,setAF]=React.useState([]);
      const [selEls,setSelEls]=React.useState([]);
      const [selMol,setSelMol]=React.useState(null);
      const [log,setLog]=React.useState([]);
      const [gameOver,setGameOver]=React.useState(null);
      const firstDraw=React.useRef(true);
      const [aiThinking, setAiThinking] = React.useState(false);
      const addLog=msg=>setLog(l=>[msg,...l]);
      const resetGame=()=>{setP(MAX_HP);setA(MAX_HP);setPH(Array.from({length:5},drawCard));setAH(Array.from({length:5},drawCard));setPF([]);setAF([]);setSelEls([]);setSelMol(null);setLog([]);setGameOver(null);setTurn('player');firstDraw.current=true;addLog('éŠæˆ²é‡ç½®ï¼Œç©å®¶å…ˆæ‰‹');};
      const [justCombinedId, setJustCombinedId] = React.useState(null);
      const [justDrawnIndices, setJustDrawnIndices] = React.useState([]);
      const [justUsedIndices, setJustUsedIndices] = React.useState([]);
//é…¸é¹¼//////////////////////////////////////////////////
// è¨ˆç®—ç©å®¶èƒ½å¦é€²è¡Œé…¸é¹¼ä¸­å’Œ
const [canCombine, setCanCombine] = React.useState(false);
      const [selEnemyMol, setSelEnemyMol] = React.useState(null);
      
const canNeutralize = (selectedMol, enemyMol) => {
  return selectedMol && enemyMol && 
    (
      ((selectedMol.kind || '').includes('base') && (enemyMol.kind || '').includes('acid')) ||
      ((selectedMol.kind || '').includes('acid') && (enemyMol.kind || '').includes('base'))
    );
};


      ////////////////////////////////////////

      
      //æŠ½ç‰Œé€šç”¨
function drawCardsTo(currentHand, setHand, count = 2, label = 'ç©å®¶') {
  const newCards = Array.from({ length: count }, drawCard);
  const updatedHand = [...currentHand, ...newCards];
  setHand(updatedHand);
  addLog(`${label}æŠ½${count}å¼µ`);
  
if (label === 'ç©å®¶' || label === 'AI') {
const startIndex = currentHand.length;
const indices = newCards.map((_, i) => startIndex + i);
setJustDrawnIndices(indices);   // å…±ç”¨å‹•ç•« index
setTimeout(() => setJustDrawnIndices([]), 800);
}


  return updatedHand;
}

      
      // å›å¾©é…ç½®ï¼šåˆ†å­å³æ™‚èˆ‡æ¯å›åˆå›è¡€
      const RECOVER_CONFIG = {
        'æ°´': { immediate: 7, perTurn: 1 },
        // å¦‚éœ€å…¶ä»–åˆ†å­å›è¡€ï¼Œå¯åœ¨æ­¤æ–°å¢
      };
      // é€šç”¨å›è¡€è§¸ç™¼å‡½å¼
      const triggerRecovery = (target, molName, trigger) => {
        const cfg = RECOVER_CONFIG[molName];
        if (!cfg || !cfg[trigger]) return;
        const heal = cfg[trigger];
        const setter = target === 'player' ? setP : setA;
        setter(hp => Math.min(MAX_HP, hp + heal));
        addLog(`${molName}${trigger==='immediate'? ' åˆæˆå›å¾©':' æ¯å›åˆå›å¾©'} ${heal} HP`);
      };
      
      //aiTakeAction() AIå‹•ä½œ
  async function aiTakeAction() {
    setAiThinking(true);  // é–‹å§‹é¡¯ç¤ºé®ç½©
    await new Promise(resolve => setTimeout(resolve, 600)); // ğŸ‘ˆ é—œéµï¼šè®“ UI æœ‰æ©Ÿæœƒé‡ç¹ª
  let hand = [...aHand];
  let field = [...aField];
  const sumAtoms = f => Object.entries(f).reduce((s, [el, n]) => s + (ELEMENTS.indexOf(el) + 1) * n, 0);

  const possible = MOLECULES.filter(m => {
    const cnt = {};
    hand.forEach(c => cnt[c.el] = (cnt[c.el] || 0) + 1);
    return Object.entries(m.formula || {}).every(([el, n]) => cnt[el] >= n);
  });

  if (possible.length > 0 && Math.random() >= 0.3) {
    possible.sort((a, b) => sumAtoms(b.formula) - sumAtoms(a.formula));
    const m = possible[0];
    const used = [];

    Object.entries(m.formula).forEach(([el, n]) => {
      for (let i = hand.length - 1; i >= 0 && n > 0; i--) {
        if (hand[i].el === el) {
          used.push(el);
          hand.splice(i, 1);
          n--;
        }
      }
    });

    setAH([...hand]); // ğŸ”¥ æ‰‹ç‰ŒåŒæ­¥
    setAF(f => [m, ...f]); // åˆ†å­å€åŒæ­¥
    addLog(`AI åˆæˆ ${m.name}`);

    if ((m.kind || '').includes('acid')) {
      const corroded = corrodeMetals(pHand, setPH);
      if (corroded > 0) addLog(`æ•µæ–¹é…¸æ€§åˆ†å­è…è•äº†ä½  ${corroded} å¼µé‡‘å±¬å¡`);
    }

    const dmg = used.reduce((s, el) => s + (ELEMENTS.indexOf(el) + 1), 0);
    applyDamage('player', dmg);
    addLog(`ä½ å—åˆ° ${dmg} å‚·`);

    let continueAction = true;
while (continueAction) {
  await new Promise(resolve => setTimeout(resolve, 600)); // å»¶é² 0.6 ç§’

  const currentHand = [...hand]; // æœ€æ–°æ‰‹ç‰Œ
  const cnt = {};
  currentHand.forEach(c => cnt[c.el] = (cnt[c.el] || 0) + 1);

  const possible = MOLECULES.filter(m =>
    Object.entries(m.formula || {}).every(([el, n]) => cnt[el] >= n)
  );

  if (possible.length > 0 && Math.random() > 0.5) { // æ©Ÿç‡æ±ºå®šæ˜¯å¦é€£çºŒå‡ºæ‰‹
    possible.sort((a, b) => sumAtoms(b.formula) - sumAtoms(a.formula));
    const m = possible[0];

    const used = [];
    Object.entries(m.formula).forEach(([el, n]) => {
      for (let i = hand.length - 1; i >= 0 && n > 0; i--) {
        if (hand[i].el === el) {
          used.push(el);
          hand.splice(i, 1);
          n--;
        }
      }
    });

    setAH([...hand]);
    setAF(f => [m, ...f]);
    addLog(`AI åˆæˆ ${m.name}`);

    if ((m.kind || '').includes('acid')) {
      const corroded = corrodeMetals(pHand, setPH);
      if (corroded > 0) addLog(`æ•µæ–¹é…¸æ€§åˆ†å­è…è•äº†ä½  ${corroded} å¼µé‡‘å±¬å¡`);
    }

    const dmg = used.reduce((s, el) => s + (ELEMENTS.indexOf(el) + 1), 0);
    applyDamage('player', dmg);
    addLog(`ä½ å—åˆ° ${dmg} å‚·`);
  } else {
    continueAction = false;
  }
}

handleEnd();
  } else {
    if (Math.random() < 0.5) {
      addLog('AI é¸æ“‡çµæŸå›åˆ');
    } else {
      let toDiscard = hand.length > 8 ? 3 : hand.length > 5 ? 2 : 1;
      const idxs = [];
      while (idxs.length < toDiscard && hand.length > 0) {
        const i = Math.floor(Math.random() * hand.length);
        if (!idxs.includes(i)) idxs.push(i);
      }
      const names = idxs.map(i => hand[i].el).join(',');
      idxs.sort((a, b) => b - a).forEach(i => hand.splice(i, 1));
      setAH([...hand]);
      addLog(`AI æ£„ç‰Œ: ${names}`);
    }

    handleEnd(); // ç¢ºå¯¦çµæŸå›åˆ
  }
    setAiThinking(false); // å‹•ä½œçµæŸå¾Œé—œæ‰é®ç½©
}

          React.useEffect(()=>resetGame(),[]);
      React.useEffect(()=>{if(gameOver) return; if(firstDraw.current){firstDraw.current=false;return;} 
        if (turn === 'player') {
const newHand = drawCardsTo(pHand, setPH, 2, 'ç©å®¶');

const acidCount = aField.filter(m => (m.kind || '').includes('acid')).length;
const strongAcidCount = aField.filter(m => (m.kind || '').includes('strong_acid')).length;

if (acidCount === 0) clearCorrosion(newHand, setPH);
if (strongAcidCount > 0) {
  const corroded = corrodeMetals(newHand, setPH, 1);
  if (corroded > 0) addLog(`æ•µæ–¹å¼·é…¸è…è•äº†ä½  ${corroded} å¼µé‡‘å±¬å¡`);
}

          // æ°´åˆ†å­æ¯å›åˆå›å¾©
          const waterCount = pField.filter(m => m.name==='æ°´').length;
          if(waterCount>0){
            const heal = waterCount * RECOVER_CONFIG['æ°´'].perTurn;
            setP(h=>Math.min(MAX_HP, h + heal));
            addLog(`æ¯å›åˆå›å¾© ${heal} HP`);
          }}
      
                          },[turn,gameOver]);
      React.useEffect(()=>{if(pHP<=0)setGameOver('lose');else if(aHP<=0)setGameOver('win');},[pHP,aHP]);  
      const applyDamage=(target,dmg)=>{let field=target==='player'?pField:aField;const setField=target==='player'?setPF:setAF;const setHp=target==='player'?setP:setA;const idx=field.findIndex(c=>c.usable);if(idx>=0){const card=field[idx];const block=ELEMENTS.indexOf(card.el)+1;showToast(`æƒ°æ€§æ°£é«”é˜»æ“‹ ${block} é»å‚·å®³`);dmg=Math.max(0,dmg-block);setField(f=>f.filter((_,i)=>i!==idx));}setHp(h=>Math.max(0,h-dmg));};  

        //åˆæˆåˆ†å­å¸¸ç”¨æ–¹æ³•  handleCombine ----
      const handleCombine = () => {
        if (turn !== 'player' || gameOver) return;
        if (selEls.length < 2) { showToast('è«‹è‡³å°‘é¸2å¼µ'); return; }
        const cards = selEls.map(i => pHand[i]);
        if (cards.some(c => c.corroded)) { showToast('è…è•å¡ç„¡æ³•åˆæˆ'); return; }
        const m = findMol(cards);
        if (!m) { showToast('ç„¡æ³•åˆæˆ'); return; }
        // åˆæˆåˆ†å­
        const newMol = { ...m, id: Date.now() };  // â­ åŠ å…¥å”¯ä¸€ ID
      setPF(f => [newMol, ...f]);
      
   setJustUsedIndices(selEls);             // è¨˜éŒ„å‹•ç•«é–‹å§‹
setJustCombinedId(newMol.id);          // åˆæˆå‹•ç•«æ¨™è¨˜

setTimeout(() => {
  setJustUsedIndices([]);              // æ¸…é™¤å‹•ç•« class
  setJustCombinedId(null);             // æ¸…é™¤åˆæˆæ¨™è¨˜
  setPH(h => h.filter((_, i) => !selEls.includes(i)));  // â­ å»¶å¾Œç§»é™¤
}, 800);  // â±ï¸ å‹•ç•«çµæŸæ™‚é–“

        addLog(`åˆæˆ ${m.name}`);


// åˆæˆé…¸
        
if ((m.kind || '').includes('acid')) {
  const corroded = corrodeMetals(aHand, setAH);
  if (corroded > 0) addLog(`é…¸æ€§åˆ†å­è…è•äº†æ•µæ–¹ ${corroded} å¼µé‡‘å±¬å¡`);
}        
        // å‚·å®³è¨ˆç®—
        const dmg = selEls.reduce((s, i) => s + (ELEMENTS.indexOf(pHand[i].el) + 1), 0);
        applyDamage('ai', dmg);
        // åˆæˆæ°´æ™‚ç«‹å³å›è¡€
        if (m.name === 'æ°´') {
          triggerRecovery('player', 'æ°´', 'immediate');
          showToast(`åˆæˆæ°´ï¼Œå›å¾© ${RECOVER_CONFIG['æ°´'].immediate} HP`);
        }
        setSelEls([]);
      };  
      const handleDiscard=()=>{if(turn!=='player'||gameOver)return; if(selEls.length<1){showToast('è«‹é¸æ“‡è¦æ£„ç‰Œ');return;}if(selEls.length>3){showToast('æœ€å¤šæ£„ç‰Œä¸‰å¼µ');return;}const names=selEls.map(i=>pHand[i].el).join(',');setPH(h=>h.filter((_,i)=>!selEls.includes(i)));addLog(`æ£„ç‰Œ: ${names}`);setSelEls([]);handleEnd();};  
      const handleEnd=()=>{if(gameOver)return;setSelEls([]);setSelMol(null);setTurn(t=>t==='player'?'ai':'player');addLog('çµæŸå›åˆ');};  
      const handleSelectEl=i=>{if(gameOver||turn!=='player')return;setSelMol(null);setSelEls(s=>s.includes(i)?s.filter(x=>x!==i):[...s,i]);};  
      
        
      const handleSelectMol = (index) => {
        if (gameOver || turn !== 'player') return;
        setSelMol(index);
      };
           
      const handleSelectEnemyMol = (index) => {
        if (gameOver || turn !== 'player') return;
        setSelEnemyMol(index);
      };
        // åˆæˆçš„è™•ç†
        const handleNeutralize = (selectedMol, enemyMol) => {
          if (!canNeutralize(selectedMol, enemyMol)) return;
        
          // ç•¶ä¸­å’ŒæˆåŠŸï¼Œæ›´æ–°åˆ†å­å€ã€ç”Ÿå‘½å€¼ç­‰ç‹€æ…‹
          setPF((f) => [...f, { ...selectedMol, effect: 'neutralized' }]);
          setAF((f) => f.filter((mol) => mol !== enemyMol)); // ç§»é™¤è¢«ä¸­å’Œçš„æ•µæ–¹åˆ†å­
        
          // é¡¯ç¤ºæˆåŠŸä¿¡æ¯
          showToast(`ä¸­å’ŒæˆåŠŸï¼${selectedMol.name} å’Œ ${enemyMol.name} åˆæˆ`);
          addLog(`æˆåŠŸä¸­å’Œ ${enemyMol.name}`);
        };
          React.useEffect(() => {
            if (selMol !== null && selEnemyMol !== null) {
              const selectedMol = pField[selMol];
              const enemyMol = aField[selEnemyMol];
              if (canNeutralize(selectedMol, enemyMol)) {
                setCanCombine(true);
              } else {
                setCanCombine(false);
              }
            } else {
              setCanCombine(false);
            }
          }, [selMol, selEnemyMol, pField, aField]);

      
      const hasWater = pField.some(m => m.name === 'æ°´') || aField.some(m => m.name === 'æ°´');
  
      
      const canUse = (turn === 'player' && !gameOver) && (
  // ç§»é™¤å°åˆ†å­ç‰Œçš„å•Ÿç”¨æ¢ä»¶
  selMol === null && 
  selEls.length === 1 && (
    pHand[selEls[0]].usable ||
    (ALKALI.includes(pHand[selEls[0]].el) && hasWater)
  )
);

      const handleUse = () => {
        if (turn !== 'player' || gameOver) return;
        if (selMol !== null) {
          const m = pField[selMol];
          addLog(`ä½¿ç”¨ åˆ†å­ ${m.name}`);
          const dmg = Object.entries(m.formula || {}).reduce(
            (s, [el, n]) => s + (ELEMENTS.indexOf(el) + 1) * n,
            0
          );
          applyDamage('ai', dmg);
          setPF((f) => f.filter((_, i) => i !== selMol));
          setSelMol(null);
        } else if (selEls.length === 1) {
          const idx = selEls[0];
          const card = pHand[idx];
          // æƒ°æ€§æ°£é«”
          if (card.usable) {
            setPF((f) => [{ el: card.el, usable: true }, ...f]);
            addLog(`ä½¿ç”¨ æƒ°æ€§æ°£é«” ${card.el}`);
            setPH((h) => h.filter((_, i) => i !== idx));
          }
          // 1Aæ—å¼•çˆ†æ°´
          else if (ALKALI.includes(card.el) && hasWater) {
            const waterCount = [...pField, ...aField].filter((mol) => mol.name === 'æ°´').length;
            const atomNum = ELEMENTS.indexOf(card.el) + 1;
            const waterMol = MOLECULES.find((m) => m.name === 'æ°´');
            const waterAtomNum = Object.entries(waterMol.formula).reduce((s, [el, n]) => s + (ELEMENTS.indexOf(el) + 1) * n, 0);
            const dmg = (atomNum + waterAtomNum) * waterCount;
            showToast(`å¯¦é©—å®¤çˆ†ç‚¸äº†ï¼é€ æˆ${dmg}é»å‚·å®³`);
            addLog(`å¯¦é©—å®¤çˆ†ç‚¸äº†ï¼é€ æˆ${dmg}é»å‚·å®³`);
            applyDamage('ai', dmg);
            // æ¶ˆè€—ä½¿ç”¨çš„å…ƒç´ ç‰Œ
            setPH((h) => h.filter((_, i) => i !== idx));
            // ç”¢ç”Ÿå°æ‡‰é¹¼æ€§åˆ†å­ä¸¦ç§»é™¤æ‰€æœ‰æ°´åˆ†å­
            const newMolName = card.el === 'Li' ? 'æ°«æ°§åŒ–é‹°' : card.el === 'Na' ? 'æ°«æ°§åŒ–éˆ‰' : 'æ°«æ°§åŒ–é‰€';
            const newMol = MOLECULES.find((m) => m.name === newMolName);
            setPF((f) => [newMol, ...f.filter((mol) => mol.name !== 'æ°´')] );
            setAF((f) => f.filter((mol) => mol.name !== 'æ°´'));((f) => f.filter((mol) => mol.name !== 'æ°´'));
          } else {
            // å…¶ä»–å…ƒç´ ä½¿ç”¨
            addLog(`ä½¿ç”¨ å…ƒç´  ${card.el}`);
            setPH((h) => h.filter((_, i) => i !== idx));
          }
          setSelEls([]);
        }
        // çµæŸç©å®¶å›åˆ
        setTurn('ai');
      };  
      React.useEffect(() => {
  if (gameOver || turn !== 'ai') return;

  const newHand = drawCardsTo(aHand, setAH, 2, 'AI');

  const acidCount = pField.filter(m => (m.kind || '').includes('acid')).length;
  const strongAcidCount = pField.filter(m => (m.kind || '').includes('strong_acid')).length;

  if (acidCount === 0) clearCorrosion(newHand, setAH);
  if (strongAcidCount > 0) {
    const corroded = corrodeMetals(newHand, setAH, 1);
    if (corroded > 0) addLog(`ä½ æ–¹å¼·é…¸è…è•äº†æ•µæ–¹ ${corroded} å¼µé‡‘å±¬å¡`);
  }

  // å»¶é²åŸ·è¡Œè¡Œå‹•ï¼ˆçµ¦ React æ›´æ–°æ™‚é–“ï¼‰
  setTimeout(() => aiTakeAction(), 600);
}, [turn, gameOver]);



      const possibleList=React.useMemo(()=>{const cnt={};pHand.forEach(c=>cnt[c.el]=(cnt[c.el]||0)+1);return MOLECULES.filter(m=>Object.entries(m.formula||{}).every(([el,n])=>cnt[el]>=n)).map(m=>`${m.name} (${Object.entries(m.formula).map(([el,n])=>n>1?`${n}${el}`:el).join(' + ')})`);},[pHand]);  


      //uiå€åŸŸ-----------------------------------------------
      return(<div className="game-container"><div className="board">
        <h1>çœŸå¯¦ç…‰é‡‘ï¼šåŒ–åˆä¹‹æˆ°</h1>
        {aiThinking && (
  <div className="overlay">
    <div className="ai-text">AI æ€è€ƒä¸­...</div>
  </div>
)}
        <img src="https://wen91027.github.io/img/BN_top.jpeg" alt="éŠæˆ²é¦–åœ–" className="bg-logo" />


        {gameOver&&<div className="overlay"><h2>{gameOver==='win'?'ä½ è´äº†':'åŒ–å­¸ä¸æœƒå°±æ˜¯ä¸æœƒ'}</h2><button onClick={resetGame}>é‡æ–°é–‹å§‹</button></div>}
        <div className="zone">
  <div className="zone-title">å°æ‰‹æ‰‹ç‰Œ</div>
  <div className="hand enemy-hand">
{aHand.map((c, i) => (
 <div key={i}
  className={`card element ${c.usable ? 'inert' : ''}${ALKALI.includes(c.el) ? ' alkali' : ''}${c.corroded ? ' corroded' : ''}${justDrawnIndices.includes(i) ? ' just-drawn' : ''}`}>
       <div className="symbol">{c.el}</div>
        <div className="number">{ELEMENTS.indexOf(c.el) + 1}</div>
        {c.usable && <div className="defense">é˜²ç¦¦å‚·å®³</div>}
        {ALKALI.includes(c.el) && <div className="explode">å¼•çˆ†æ°´</div>}
      </div>
    ))}
  </div>
</div>
        <div className="hp-section"><span className="hp-label">AI HP</span><div className="hp-bar"><div className="hp-inner" style={{width:`${aHP/MAX_HP*100}%`}}/></div><span>{aHP}</span></div>

        {/* å°æ‰‹åˆ†å­å€ */}
        <div className="zone"><div className="zone-title">å°æ‰‹åˆ†å­å€</div><div className="field">
           {aField.map((c,i)=>
        <div key={i} className={`card molecule ${c.effect} ${(c.kind || '').includes('acid') ? 'acid' : ''} ${c.usable ? 'inert' : ''}${selEnemyMol === i ? ' selected' : ''}${justCombinedId === c.id ? 'newly-created' : ''}
`}onClick={() => handleSelectEnemyMol(i)}>
            <div className="symbol">{c.usable?c.el:c.name}</div>
            {c.usable&&<div className="block-info">é˜»æ“‹{ELEMENTS.indexOf(c.el)+1}å‚·å®³</div>}
             {c.effect === 'recover' &&
          <div className="recover-info">
            æŒçºŒå›å¾©{RECOVER_CONFIG['æ°´'].perTurn}HP
          </div>
        }
             {c.effect === 'corrosion' && (
    <div className="corrosion-info">è…è•é‡‘å±¬</div>
  )}
          </div>
        )}</div></div>

        {/* logå€ */}
        <div className="log">{log.slice(0,5).map((l,i)=>
          <div key={i} style={{color:i===0?'#ff0':'#ccc'}}>{l}</div>
        )}</div>


        {/* æˆ‘æ–¹åˆ†å­å€ */}
        <div className="zone"><div className="zone-title">æˆ‘æ–¹åˆ†å­å€</div><div className="field">
          {pField.map((c,i)=>
          <div key={i} className={`card molecule ${c.effect} ${(c.kind || '').includes('acid') ? 'acid' : ''} ${c.usable ? 'inert' : ''}${selMol === i ? ' selected' : ''}${justCombinedId === c.id ? 'newly-created' : ''}
`} onClick={() => handleSelectMol(i)}>           
            {c.usable
              ? React.createElement(React.Fragment, null,
                  React.createElement("div", { className: "symbol" }, c.el),
                  React.createElement("div", { className: "block-info" }, `é˜»æ“‹${ELEMENTS.indexOf(c.el)+1}å‚·å®³`)
                )
              : React.createElement("div", { className: "name" }, c.name)
            }
                    {c.effect === 'recover' &&
          <div className="recover-info">
            æŒçºŒå›å¾©{RECOVER_CONFIG['æ°´'].perTurn}HP
          </div>
        }
              {c.effect === 'corrosion' && (
    <div className="corrosion-info">è…è•é‡‘å±¬</div>
  )}
            
          </div>
        )}</div></div>

          <div>
      <div>
        {/* å¦‚æœå¯ä»¥ä¸­å’Œï¼Œé¡¯ç¤ºåˆæˆæŒ‰éˆ• */}
 {selMol !== null && selEnemyMol !== null && (
  <button 
    onClick={() => handleNeutralize(pField[selMol], aField[selEnemyMol])}
    disabled={!canCombine}
  >
    ä¸­å’Œ
  </button>
)}
      </div>
    </div>

        
             <div className="hp-section"><span className="hp-label">ç©å®¶ HP</span><div className="hp-bar"><div className="hp-inner" style={{width:`${pHP/MAX_HP*100}%`}}/></div><span>{pHP}</span></div>

        <div className="zone"><div className="zone-title">ç©å®¶æ‰‹ç‰Œ</div><div className="hand">{pHand.map((c,i)=>
 <div key={i}
  className={`card element ${c.usable ? 'inert' : ''}${ALKALI.includes(c.el) ? ' alkali' : ''}${c.corroded ? ' corroded' : ''}${selEls.includes(i) ? ' selected' : ''}${justDrawnIndices.includes(i) ? ' just-drawn' : ''}${justUsedIndices.includes(i) ? ' combine-out' : ''}`}
  onClick={() => handleSelectEl(i)}>
            <div className="symbol">{c.el}</div>
            <div className="number">{ELEMENTS.indexOf(c.el)+1}</div>
            {c.usable&&<div className="defense">é˜²ç¦¦å‚·å®³</div>}
            {ALKALI.includes(c.el)&&<div className="explode">å¼•çˆ†æ°´</div>}
          </div>
        )}</div></div>
        <div className="prompt">{possibleList.length>0?`å¯åˆæˆ: ${possibleList.join('ã€')}`:'ç„¡å¯åˆæˆåŒ–åˆç‰©'}</div>
        <div className="controls"><button onClick={handleCombine} disabled={turn!=='player'||gameOver||selEls.length<2}>åˆæˆ</button><button onClick={handleUse} disabled={!canUse}>ä½¿ç”¨</button><button onClick={handleDiscard} disabled={turn!=='player'||gameOver||selEls.length<1}>æ£„ç‰Œ</button><button onClick={handleEnd} disabled={turn!=='player'||gameOver}>çµæŸå›åˆ</button></div>
         </div></div>);
    }
    ReactDOM.render(<App/>,document.getElementById('root'));
  </script>
</body>
</html>


