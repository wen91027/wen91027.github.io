<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>çœŸå¯¦ç…‰é‡‘ï¼šåŒ–åˆä¹‹æˆ°</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400&display=swap" rel="stylesheet" />
  <style>


    
    body { margin:0; background:#0d1321; color:#fff; font-family:'Orbitron',sans-serif; text-align:center; }
    .toast { position:fixed; top:150px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); color:#f55; padding:8px 16px; border:1px solid #f55; border-radius:4px; z-index:2000; opacity:0; transition:opacity 0.3s; }
    .toast.show { opacity:1; }
    .game-container { display:flex; flex-direction:column; align-items:center; padding:1em; }
    .board { width:90%; max-width:800px; background:#1a242f; border:2px solid #444; border-radius:10px; padding:1em; position:relative; }
    .overlay { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:1000; }
    .overlay button { margin-top:1em; }
    .hp-section { display:flex; align-items:center; justify-content:center; margin:8px 0; }
    .hp-label { margin-right:8px; }
    .hp-bar { flex:1; background:#222; border:1px solid #0ff; border-radius:4px; height:16px; margin:0 8px; overflow:hidden; }
    .hp-inner { background:#0ff; height:100%; }
    .zone { margin:12px 0; }
    .zone-title { color:#ccc; margin-bottom:4px; }
    .hand {
      height: 120px; 
  display: flex;
  flex-wrap: nowrap;         /* â— ä¸æ›è¡Œ */
  overflow-x: auto;          /* â— é–‹å•Ÿæ©«å‘æ»¾å‹• */
  justify-content: flex-start;
  padding: 0.5em 0;
  gap: 1em;
  scrollbar-width: thin;     /* Firefox æ”¯æ´ */
}
    .field { display:flex; flex-wrap:nowrap; justify-content:flex-start; overflow-x:auto; }
    
    .card { border:1px solid #555; border-radius:10px; padding:8px; margin:4px; transition:transform .2s; display:flex; flex-direction:column; align-items:center; }
    .card:hover { transform:translateY(-4px); }
    .card.element { width:75px; height:100px; background:#1f2a36;flex-shrink: 0; cursor:pointer; position:relative; }
    .card.element.inert { background:#555; }
    .card.element.alkali { background:#a00; }
    .card.element .symbol {  
          font-size: 2em;
      margin-top: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 1; /* è®“å®ƒæ’æ»¿çˆ¶å…ƒç´ é«˜åº¦ï¼Œä¾¿æ–¼ç½®ä¸­ */}
    .card.element .number { position:absolute; top:4px; right:6px; font-size:1.5em; color:#0ff; }
    
    .card.element .defense { position:absolute; bottom:4px; width:100%; font-size:1em; color:#fff; text-align:center; }
    .card.element .explode { position:absolute; bottom:4px; width:100%; font-size:1em; color:#ff0; text-align:center; }
    .card.element.selected { border-color:#0f0; box-shadow:0 0 6px #0f0; }
    .card.element.corroded { background: linear-gradient(45deg, #555 25%, #333 25%, #333 50%, #555 50%, #555 75%, #333 75%, #333 100%); background-size: 6px 6px;position: relative;}
    .card.element.corroded::after {content: "è…è•";position: absolute;top: 2px;left: 50%;transform: translateX(-50%);font-size: 0.4em;color: #ff6688;}
    
    .card.molecule { width:80px; min-height:80px; background:#14232e; cursor:pointer; position:relative; }
    .card.molecule .name {
  font-size: 1.3em; /* é è¨­å¤§å° */
  text-align: center;
  padding: 4px 2px;
}
    /* effect-specific backgrounds */
    .card.molecule.organic      { background:#663300; }
    .card.molecule.recover   { border:2px solid #fff; box-shadow:0 0 8px #fff;}
    .card.molecule.inert     { background:#555; border:2px solid #fff; box-shadow:0 0 8px #00FFFF; pointer-events:none; display:flex; flex-direction:column; justify-content:center; align-items:center; }
    .card.molecule.inert .symbol    { font-size:1.5em; margin-top:8px; }
    .card.molecule.inert .block-info { font-size:1em; color:#fff; }
    .card.molecule.recover .symbol     { font-size: 1.5em; margin-top:8px; }
    .card.molecule.recover .recover-info { position:absolute; bottom:4px; width:100%; font-size:1em; color:#fff; text-align:center; }
    .card.molecule.acid {  background: #BF0060;}
    .card.molecule.base {  background: #005AB5;}
    .card.molecule.corrosion .corrosion-info {
        position: absolute;
        bottom: 4px;
        width: 100%;
        font-size: 1em;
        color: #ff6688; /* æ¯”è¼ƒåç²‰ç´…ç´…è‰² */
        text-align: center;
      }
    .card.molecule.alkali .alkali-info {
        position: absolute;
        bottom: 4px;
        width: 100%;
        font-size: 1em;
        color: #66ccff; /* æ¯”è¼ƒåè—è‰²ï¼Œä»£è¡¨é¹¼æ€§ */
        text-align: center;
      }
          .card.molecule.disabled {
            opacity: 0.6;
            filter: grayscale(1);
          }
    .card.molecule.disabled::after {
        content: "è®Šæ€§";
        position: absolute;
        top: 2px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.6em;
        color: #ccc;
      }

    
    .card.molecule.selected { border:2px solid #0f0; box-shadow:0 0 6px #0f0; }
 
    .card.hint-glow {
  border-color: #fff;
  animation: hint-glow-pulse 1.6s ease-in-out infinite;
}

@keyframes hint-glow-pulse {
  0%   { box-shadow: 0 0 0px rgba(255,255,255,0); }
  50%  { box-shadow: 0 0 8px 3px rgba(255,255,255,0.5); }
  100% { box-shadow: 0 0 0px rgba(255,255,255,0); }
}


    .controls {
       width: 100%;
      display: flex;
      flex-direction: column; /* æ”¹ç‚ºå‚ç›´æ’åˆ— */
      align-items: center;
      padding: 12px 0 30px; /* ä¿ç•™åº•éƒ¨ç©ºé–“ */
      background: rgba(13, 19, 33, 0.95);
      border-top: 1px solid #0ff;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.6);
      gap: 8px;
          }

.grid-controls {
  display: grid;
  grid-template-columns: repeat(2, 1fr); /* å…©æ¬„ */
  gap: 12px;
  justify-items: center;
  padding: 16px;
  background: rgba(13, 19, 33, 0.95);
  border-top: 1px solid #0ff;
  box-shadow: 0 -2px 10px rgba(0,0,0,0.6);
  padding-bottom: 24px;

}


   button {
  font-family: 'Orbitron', sans-serif;
  background: #112233;
  color: #0ff;
  border: 1px solid #0ff;
  border-radius: 6px;
  padding: 12px 20px;      /* â† æ›´å¤§çš„å…§é‚Šè· */
  margin: 0 6px;
  cursor: pointer;
  font-size: 2em;        /* â† æ›´å¤§çš„å­—é«” */
  transition: background 0.2s;
     width: 100%
}
    button:hover:enabled { background:#334455; }
    
    button:disabled { opacity:0.5; cursor:not-allowed; }
    .prompt { color:#8cf; margin-top:4px; }
    .log { text-align:center; max-height:120px; overflow-y:auto; background:#112233; padding:8px; border:1px solid #333; border-radius:4px; margin-top:8px; font-size:1em; }
    .enemy-hand .card { opacity: 0.6;  pointer-events: none;}
    .hp-section { flex-direction: column; }
    .hp-label, .hp-text { margin: 2px 0; }
    .hp-bar { flex: none !important; width: 100% !important; margin: 4px 0; }
    .zone-title { font-size: 0.9em; }
    .prompt, .log { font-size: 1em; }
    .bg-logo {  width: 100%;  max-width: 100%;  height: auto;  display: block;  margin: 0 auto 1em;}
/*æ–°æ±è¥¿æ¸¬è©¦*/

    .board {padding-bottom: 700px; /* æˆ–è¦–æŒ‰éˆ•å€å¡Šé«˜åº¦è€Œå®šï¼Œç¢ºä¿ä¸‹æ–¹å…§å®¹ä¸è¢«æ“‹ä½ */}



.floating-container {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  z-index: 1000;
  background: rgba(13, 19, 33, 0.95);
  padding: 8px 0;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 8px;
}

    
    /* å›ºå®šæµ®å‹•å€å¡Šå®¹å™¨ */
.floating-ui {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 8px;
}

/* ç©å®¶ HP æ¢æ¨£å¼èª¿æ•´ï¼ˆæ©«å‘ï¼‰ */
.floating-ui .hp-section {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  width: 90%;       /* â­ çµ¦å€‹æœ€å¤§å¯¬åº¦ */
  gap: 4px;
   padding: 8px 0;
    text-align: center;
}

.floating-ui .hp-bar {
  flex: 1;
   /* â­ è‡ªè¨‚æœ€å¤§å¯¬åº¦ */
   width: 100%;
  height: 20px;
}

    .hp-label {
  font-size: 1em;
  color: #0ff;
}

.hp-text {
  font-size: 1.2em;
  color: #fff;
}
    
.floating-ui .hand {
  display: flex;
  flex-wrap: nowrap;     /* â— ä¸æ›è¡Œ */
  overflow-x: auto;      /* â— é–‹å•Ÿæ©«å‘æ»¾å‹• */
    -webkit-overflow-scrolling: touch;  /* åœ¨ iOS ä¸Šå•Ÿç”¨æ…£æ€§æ»¾å‹• */
  scrollbar-color: #0ff #112233;       /* æ›´æ˜é¡¯çš„æ²å‹•æ¢è‰²å½© */
  justify-content: flex-start;
  padding: 0.5em 0;
  gap: 1em;
  scrollbar-width: thin; /* Firefox æ”¯æ´ */
}

.floating-ui .zone {
  width: 100%;
  overflow: hidden; /* å¯åŠ å¯ä¸åŠ  */
}


    
   /* å‹•ç•«æ•ˆæœæ–°å¢åœ¨é€™ */

    /* AIæ€è€ƒé®ç½© */
.ai-text {font-size: 1.5em;color: #0ff;animation: pulse 1s infinite;text-shadow: 0 0 10px #0ff;}

@keyframes pulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.6; }
  100% { transform: scale(1); opacity: 1; }
}

/* ç‰Œå¾ä¸Šå¾€ä¸‹é£›ä¸¦æ·¡å…¥ */
    
@keyframes slide-down {
  0% {transform: translateY(-100px);opacity: 0;}
  100% {transform: translateY(0);opacity: 1;}
}
/* å‰›åˆæˆçš„ç‰Œ */
.card.molecule.newly-created { animation: slide-down 0.6s ease-out;}
/* æ–°çš„é£›å…¥å‹•ç•« */
@keyframes fly-in {
  0% {
    transform: translateY(-80px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
}

 /* åˆæˆå‹•ç•«ï¼šåˆ†å­ */
.card.molecule.just-combined {
  animation: fly-in 0.5s ease-out;
  z-index: 10;
}

/* æŠ½å¡å‹•ç•«ï¼šå…ƒç´  */
.card.element.just-drawn {
  animation: fly-in 0.5s ease-out;
  z-index: 10;
}
/* åˆæˆå‹•ç•«ï¼šå…ƒç´  */
    .card.element.combine-out {
  animation: combine-out 0.5s ease-in-out forwards;
}

@keyframes combine-out {
  0%   { transform: scale(1) translateY(0); opacity: 1; }
  100% { transform: scale(0.2) translateY(-40px); opacity: 0; }
}

/* åˆæˆå‹•ç•«ï¼šç‰¹æ•ˆå…‰ */
    
.card.molecule.flash {
  position: relative;
}

.card.molecule.flash::after {
  content: "";
  position: absolute;
  top: -6px;
  left: -6px;
  width: calc(100% + 12px);
  height: calc(100% + 12px);
  border-radius: 10px;
  border: 2px solid rgba(255, 255, 255, 0.8);
  animation: flash-glow 0.8s ease-out;
  pointer-events: none;
  z-index: 999;
}

@keyframes flash-glow {
  0% { box-shadow: 0 0 0px #fff; transform: scale(1); }
  50% { box-shadow: 0 0 20px #fff; transform: scale(1.05); }
  100% { box-shadow: 0 0 0px #fff; transform: scale(1); }
  z-index: 999;
}

    .card.molecule.newly-created {
  animation: flash-glow 0.6s ease-out;
      z-index: 999;
}
    
  }



    
  </style>
  
      </head>
<body>
  <div id="toast" class="toast"></div>
  <div id="root"></div>
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script src="https://wen91027.github.io/deta/molecules_full.js"></script>
  <script type="text/babel">
const ELEMENTS = window.ELEMENTS;
const WEIGHTS = window.WEIGHTS;
    const MOLECULES = window.MOLECULES;
const ALKALI = window.ALKALI;
const METALS = window.METALS;
const NEUTRALIZATION_RECIPES = window.NEUTRALIZATION_RECIPES;
    const RECOVER_CONFIG = window.RECOVER_CONFIG;
    


    
    const MAX_HP = 128;
  
    const drawPool = [];
    ELEMENTS.forEach(e => {
      const w = WEIGHTS[e]||3;
      for (let i=0;i<Math.round(w*2);i++) drawPool.push(e);
    });
    function drawCard(){
      const el = drawPool[Math.floor(Math.random()*drawPool.length)];
      return { el, corroded:false, usable:['He','Ne','Ar'].includes(el) };
    }

   


    //å¯åˆæˆåˆ†å­åˆ¤å®š
    function findMol(sel){
      const cnt={}; sel.forEach(c=>c&&c.el&&(cnt[c.el]=(cnt[c.el]||0)+1));
      for(const m of MOLECULES){ const f=m.formula;
        if(Object.values(f).reduce((a,b)=>a+b,0)!==sel.length) continue;
        let ok=true; for(const k in f) if(cnt[k]!==f[k]) ok=false;
        for(const k in cnt) if(!f[k]) ok=false;
        if(ok) return m;
      }
      return null;
    }
    // å…±ç”¨å¡ç‰Œä½¿ç”¨é‚è¼¯æ¨¡çµ„ ////////////////////
function useElementCard(card, {userId, user, setUserHand, setUserField,opponentField, setOpponentField,applyDamage, addLog, showToast
}) {

  // æƒ°æ€§æ°£é«”ï¼šé˜²ç¦¦ç›¾ç‰Œ
  if (card.usable) {
    setUserField(f => [{ el: card.el, usable: true }, ...f]);
    addLog(`ä½¿ç”¨ æƒ°æ€§æ°£é«” ${card.el}`);
    return true;
  }

  // 1Aæ— + å ´ä¸Šæœ‰æ°´ï¼šå¼•çˆ†æ°´é€ æˆçˆ†ç‚¸å‚·å®³
  const hasWater = [...opponentField, ...user.field].some(m => m.name === 'æ°´');
  if (ALKALI.includes(card.el) && hasWater) {
    const waterCount = [...opponentField, ...user.field].filter(m => m.name === 'æ°´').length;
    const atomNum = ELEMENTS.indexOf(card.el) + 1;
    const waterMol = MOLECULES.find(m => m.name === 'æ°´');
    const waterAtomNum = Object.entries(waterMol.formula).reduce((s, [el, n]) => s + (ELEMENTS.indexOf(el) + 1) * n, 0);
    const dmg = (atomNum + waterAtomNum) * waterCount;

    showToast(`å¯¦é©—å®¤çˆ†ç‚¸äº†ï¼é€ æˆ${dmg}é»å‚·å®³`);
    addLog(`å¼•çˆ†æ°´é€ æˆ ${dmg} å‚·å®³`);
    const opponentId = userId === 'player' ? 'ai' : 'player';
    applyDamage(opponentId, dmg);


    // æ¸…é™¤æ‰€æœ‰æ°´åˆ†å­ï¼Œä¸¦åŠ å…¥é¹¼
    const newMolName = card.el === 'Li' ? 'æ°«æ°§åŒ–é‹°' : card.el === 'Na' ? 'æ°«æ°§åŒ–éˆ‰' : 'æ°«æ°§åŒ–é‰€';
    const newMol = MOLECULES.find(m => m.name === newMolName);
    setUserField(f => [newMol, ...f.filter(m => m.name !== 'æ°´')]);
    setOpponentField(f => f.filter(m => m.name !== 'æ°´'));

    return true;
  }

  // å…¶ä»–å…ƒç´ å¡çš„ fallback è™•ç†
  addLog(`ä½¿ç”¨ å…ƒç´  ${card.el}`);
  return true;
}

function MoleculeEffect(molecule, {userId,opponentHand, setOpponentHand,applyDamage, addLog, showToast,triggerRecovery,setOpponentField
}) {
  // è§¸ç™¼è…è•
  if ((molecule.kind || '').includes('acid')) {
    const isStrong = (molecule.kind || '').includes('strong_acid');
    const corroded = corrodeMetals(opponentHand, setOpponentHand, 2); // â† ç„¡è«–å¼·é…¸æˆ–é…¸éƒ½è…è• 2 å¼µ

    if (corroded > 0) {
      const label = isStrong ? 'å¼·é…¸' : 'é…¸æ€§åˆ†å­';
      const msg = `${userId === 'player' ? label + 'è…è•äº†æ•µæ–¹' : 'æ•µæ–¹' + label + 'è…è•äº†ä½ '} ${corroded} å¼µé‡‘å±¬å¡`;
      addLog(msg);
    }
  }

  // ç«‹å³å›è¡€ï¼ˆex. æ°´ï¼‰
  if (molecule.name === 'æ°´') {
    triggerRecovery(userId, 'æ°´', 'immediate');
    showToast(`åˆæˆæ°´ï¼Œå›å¾© ${RECOVER_CONFIG['æ°´'].immediate} HP`);
  }

  // è§¸ç™¼è®Šæ€§
if ((molecule.kind || '').includes('base')) {
  const isStrong = (molecule.kind || '').includes('strong_base');
  const count = isStrong ? 2 : 1;

 setOpponentField(prev => {
  const newField = [...prev];

  const sorted = newField
    .map((m, i) => ({ m, i }))
    .filter(({ m }) => !(m.kind || '').includes('acid') && !m.disabled)
    .sort((a, b) => {
      if (a.m.effect === 'recover' && b.m.effect !== 'recover') return -1;
      if (a.m.effect !== 'recover' && b.m.effect === 'recover') return 1;
      return 0;
    });

  const toDisable = sorted.slice(0, count);
  toDisable.forEach(({ i }) => {
    newField[i] = { ...newField[i], disabled: true };
  });

  if (toDisable.length > 0) {
    addLog(`${isStrong ? 'å¼·é¹¼' : 'é¹¼æ€§åˆ†å­'}è®Šæ€§äº†æ•µæ–¹ ${toDisable.length} å¼µåˆ†å­`);
  }

  return newField;
});


  
}


  
  // ğŸ‘‰ ä½ å¯æ–¼æ­¤æ“´å……æ›´å¤šè¢«å‹•æ•ˆæœï¼ˆå¦‚æ¯’ã€ç‡ƒç‡’ç­‰ï¼‰


  
}

    function MoleculeOnCombine(molecule, {sourceEls,userId,opponentId,applyDamage,addLog,showToast,triggerRecovery,opponentHand,setOpponentHand,
  setOpponentField 
}) {
  // åŸ·è¡Œåˆ†å­æ•ˆæœï¼ˆè…è•ã€æ°´å›å¾©ç­‰ï¼‰
  MoleculeEffect(molecule, {
    userId,
    opponentHand,
    setOpponentHand,
    applyDamage,
    addLog,
    showToast,
    triggerRecovery,
  setOpponentField 
  });

  // åˆæˆé€ æˆåŸºç¤å‚·å®³ï¼ˆä¾†è‡ªä½¿ç”¨çš„åŸå­åºåŠ ç¸½ï¼‰
  const dmg = sourceEls.reduce((sum, card) => sum + (ELEMENTS.indexOf(card.el) + 1), 0);
  applyDamage(opponentId, dmg);
  addLog(`${userId === 'player' ? 'å°æ•µäººé€ æˆ' : 'ä½ å—åˆ°'} ${dmg} å‚·å®³`);
}


    
//è…è•ç›¸é—œå‡½å¼
function corrodeMetals(hand, setHand, count = 2) {  // <--- åŠ ä¸€å€‹ count = 2 é è¨­
  const metals = METALS;
  const metalIndices = hand
    .map((c, i) => (metals.includes(c.el) && !c.corroded ? i : -1))
    .filter(i => i !== -1);

  if (metalIndices.length > 0) {
    const shuffle = [...metalIndices].sort(() => Math.random() - 0.5);
    const selected = shuffle.slice(0, Math.min(count, shuffle.length));
    const newHand = [...hand];
    selected.forEach(i => newHand[i] = { ...newHand[i], corroded: true });
    setHand(newHand);
    return selected.length;
  }
  return 0;
}
//æ¸…é™¤è…è•
    function clearCorrosion(hand, setHand) {
  const newHand = hand.map(c => c.corroded ? { ...c, corroded: false } : c);
  setHand(newHand);
}
    
    function showToast(msg){const t=document.getElementById('toast');t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),2000);}
    
  

    //APP ä¸»è¦éŠæˆ²æ®µè½-----------------------------------------------
    function App(){

        // å…¶é¤˜ç‹€æ…‹é‰¤å­èˆ‡å‡½å¼...
      const [turn,setTurn]=React.useState('player');
      const [pHP,setP]=React.useState(MAX_HP);
      const [aHP,setA]=React.useState(MAX_HP);
      const [pHand,setPH]=React.useState([]);
      const [aHand,setAH]=React.useState([]);
      const [pField,setPF]=React.useState([]);
      const [aField,setAF]=React.useState([]);
      const [selEls,setSelEls]=React.useState([]);
      const [selMol,setSelMol]=React.useState(null);
      const [log,setLog]=React.useState([]);
      const [gameOver,setGameOver]=React.useState(null);
      const firstDraw=React.useRef(true);
      const [aiThinking, setAiThinking] = React.useState(false);
      const addLog=msg=>setLog(l=>[msg,...l]);
      const resetGame=()=>{setP(MAX_HP);setA(MAX_HP);setPH(Array.from({length:5},drawCard));setAH(Array.from({length:5},drawCard));setPF([]);setAF([]);setSelEls([]);setSelMol(null);setLog([]);setGameOver(null);setTurn('player');firstDraw.current=true;addLog('éŠæˆ²é‡ç½®ï¼Œç©å®¶å…ˆæ‰‹');};
      const [justCombinedId, setJustCombinedId] = React.useState(null);
      const [pJustDrawnIndices, setPJustDrawnIndices] = React.useState([]);
      const [aJustDrawnIndices, setAJustDrawnIndices] = React.useState([]);

      const [justUsedIndices, setJustUsedIndices] = React.useState([]);
//é…¸é¹¼//////////////////////////////////////////////////
// è¨ˆç®—ç©å®¶èƒ½å¦é€²è¡Œé…¸é¹¼ä¸­å’Œ
const [canCombine, setCanCombine] = React.useState(false);
      const [selEnemyMol, setSelEnemyMol] = React.useState(null);
      
const canNeutralize = (selectedMol, enemyMol) => {
  return selectedMol && enemyMol && 
    (
      ((selectedMol.kind || '').includes('base') && (enemyMol.kind || '').includes('acid')) ||
      ((selectedMol.kind || '').includes('acid') && (enemyMol.kind || '').includes('base'))
    );
};


      ////////////////////////////////////////

      
      //æŠ½ç‰Œé€šç”¨
function drawCardsTo(currentHand, setHand, count = 2, label = 'ç©å®¶') {
  const newCards = Array.from({ length: count }, drawCard);
  const updatedHand = [...currentHand, ...newCards];
  setHand(updatedHand);
  addLog(`${label}æŠ½${count}å¼µ`);
  
if (label === 'ç©å®¶' || label === 'AI') {
const startIndex = currentHand.length;
const indices = newCards.map((_, i) => startIndex + i);
  if (label === 'ç©å®¶') {
    setPJustDrawnIndices(indices);
    setTimeout(() => setPJustDrawnIndices([]), 800);
  } else if (label === 'AI') {
    setAJustDrawnIndices(indices);
    setTimeout(() => setAJustDrawnIndices([]), 800);
  }
}


  return updatedHand;
}

      

      // é€šç”¨å›è¡€è§¸ç™¼å‡½å¼
      const triggerRecovery = (target, molName, trigger) => {
        const cfg = RECOVER_CONFIG[molName];
        if (!cfg || !cfg[trigger]) return;
        const heal = cfg[trigger];
        const setter = target === 'player' ? setP : setA;
        setter(hp => Math.min(MAX_HP, hp + heal));
        addLog(`${molName}${trigger==='immediate'? ' åˆæˆå›å¾©':' æ¯å›åˆå›å¾©'} ${heal} HP`);
      };



      
      //aiTakeAction() AIå‹•ä½œ
      async function aiTakeAction() {
              setAiThinking(true);  // é–‹å§‹é¡¯ç¤ºé®ç½©
              await new Promise(resolve => setTimeout(resolve, 600)); // ğŸ‘ˆ é—œéµï¼šè®“ UI æœ‰æ©Ÿæœƒé‡ç¹ª
            let hand = [...aHand];
            let field = [...aField];
            const sumAtoms = f => Object.entries(f).reduce((s, [el, n]) => s + (ELEMENTS.indexOf(el) + 1) * n, 0);
          
            const possible = MOLECULES.filter(m => {
              const cnt = {};
              hand.forEach(c => cnt[c.el] = (cnt[c.el] || 0) + 1);
              return Object.entries(m.formula || {}).every(([el, n]) => cnt[el] >= n);
            });
          
            if (possible.length > 0 && Math.random() >= 0.3) {
              possible.sort((a, b) => sumAtoms(b.formula) - sumAtoms(a.formula));
              const m = possible[0];
              const used = [];
          
              Object.entries(m.formula).forEach(([el, n]) => {
                for (let i = hand.length - 1; i >= 0 && n > 0; i--) {
                  if (hand[i].el === el) {
                    used.push(el);
                    hand.splice(i, 1);
                    n--;
                  }
                }
              });
          
              setAH([...hand]); // ğŸ”¥ æ‰‹ç‰ŒåŒæ­¥
              const newMol = { ...m, id: Date.now()+ Math.random() };
              setAF(f => [newMol, ...f]);
              addLog(`AI åˆæˆ ${newMol.name}`);

                      
              MoleculeOnCombine(newMol, {
              sourceEls: used.map(el => ({ el })), // æ¨¡æ“¬å…ƒç´ å¡ç‰‡æ ¼å¼
              userId: 'ai',
              opponentId: 'player',
              applyDamage,
              addLog,
              showToast,
              triggerRecovery,
              opponentHand: pHand,
              setOpponentHand: setPH,
                setOpponentField: setPF
            });

          
              let continueAction = true;
          while (continueAction) {
            await new Promise(resolve => setTimeout(resolve, 600)); // å»¶é² 0.6 ç§’
          
            const currentHand = [...hand]; // æœ€æ–°æ‰‹ç‰Œ
            const cnt = {};
            currentHand.forEach(c => cnt[c.el] = (cnt[c.el] || 0) + 1);
          
            const possible = MOLECULES.filter(m =>
              Object.entries(m.formula || {}).every(([el, n]) => cnt[el] >= n)
            );
          
            if (possible.length > 0 && Math.random() > 0.5) { // æ©Ÿç‡æ±ºå®šæ˜¯å¦é€£çºŒå‡ºæ‰‹
              possible.sort((a, b) => sumAtoms(b.formula) - sumAtoms(a.formula));
              const m = possible[0];
          
              const used = [];
              Object.entries(m.formula).forEach(([el, n]) => {
                for (let i = hand.length - 1; i >= 0 && n > 0; i--) {
                  if (hand[i].el === el) {
                    used.push(el);
                    hand.splice(i, 1);
                    n--;
                  }
                }
              });
          
              setAH([...hand]);
           const newMol = { ...m, id: Date.now()+ Math.random() };
            setAF(f => [newMol, ...f]);
            addLog(`AI åˆæˆ ${newMol.name}`);


              MoleculeOnCombine(newMol, {
            sourceEls: used.map(el => ({ el })), // æ¨¡æ“¬å…ƒç´ å¡ç‰‡æ ¼å¼
            userId: 'ai',
            opponentId: 'player',
            applyDamage,
            addLog,
            showToast,
            triggerRecovery,
            opponentHand: pHand,
            setOpponentHand: setPH,
                setOpponentField: setAF
          });

  
            } else {
              continueAction = false;
            }
          }
          
          handleEnd();
            
            
            
            } else {

    
        // ğŸ§  å˜—è©¦ä½¿ç”¨æƒ°æ€§æ°£é«”æˆ–1Aæ—ï¼ˆå…±ç”¨é‚è¼¯ï¼‰
        const specialIdx = hand.findIndex(c =>
          c.usable || (ALKALI.includes(c.el) && [...aField, ...pField].some(m => m.name === 'æ°´'))
        );
        
        if (specialIdx !== -1) {
          const card = hand[specialIdx];
          const used = useElementCard(card, {
            userId: 'ai',
            user: { field: aField },
            setUserHand: setAH,
            setUserField: setAF,
            opponentField: pField,
            setOpponentField: setPF,
            applyDamage,
            addLog,
            showToast
          });
          if (used) {
            hand.splice(specialIdx, 1);
            setAH([...hand]);
            handleEnd();
            setAiThinking(false);
            return;
          }
        }


              
              if (Math.random() < 0.5) {
                addLog('AI é¸æ“‡çµæŸå›åˆ');
              } else {
                let toDiscard = hand.length > 8 ? 3 : hand.length > 5 ? 2 : 1;
                const idxs = [];
                while (idxs.length < toDiscard && hand.length > 0) {
                  const i = Math.floor(Math.random() * hand.length);
                  if (!idxs.includes(i)) idxs.push(i);
                }
                const names = idxs.map(i => hand[i].el).join(',');
                idxs.sort((a, b) => b - a).forEach(i => hand.splice(i, 1));
                setAH([...hand]);
                addLog(`AI æ£„ç‰Œ: ${names}`);
              }
          
              handleEnd(); // ç¢ºå¯¦çµæŸå›åˆ
            }
              setAiThinking(false); // å‹•ä½œçµæŸå¾Œé—œæ‰é®ç½©
          }

          React.useEffect(()=>resetGame(),[]);
      React.useEffect(()=>{if(gameOver) return; if(firstDraw.current){firstDraw.current=false;return;} 
                
                           //ç©å®¶å›åˆ
                           if (turn === 'player') {
        const newHand = drawCardsTo(pHand, setPH, 2, 'ç©å®¶');

                  //å¼·é…¸æŒçºŒè…è•
        const hasStrongAcid = aField.some(m => (m.kind || '').includes('strong_acid'));
        if (hasStrongAcid) {
          const corroded = corrodeMetals(newHand, setPH, 1);
          if (corroded > 0) addLog(`æ•µæ–¹å¼·é…¸è…è•äº†ä½  ${corroded} å¼µé‡‘å±¬å¡`);
        }

          // æ°´åˆ†å­æ¯å›åˆå›å¾©
          const waterCount = pField.filter(m => m.name==='æ°´').length;
          if(waterCount>0){
            const heal = waterCount * RECOVER_CONFIG['æ°´'].perTurn;
            setP(h=>Math.min(MAX_HP, h + heal));
            addLog(`æ¯å›åˆå›å¾© ${heal} HP`);
          }

                  //å¼·é¹¼æŒçºŒè®Šæ€§
           const hasStrongBase = pField.some(m => (m.kind || '').includes('strong_base'));
          if (hasStrongBase) {
  setAF(prev => {
    const newField = [...prev];
    for (let i = 0; i < newField.length; i++) {
      const m = newField[i];
      if ((m.kind || '').includes('acid') || m.disabled) continue;
      newField[i] = { ...m, disabled: true };
      addLog(`å¼·é¹¼æŒçºŒè®Šæ€§äº†æ•µæ–¹ ${m.name}`);
      break;
    }
    return newField;
  });
}

                
                }
      
                          },[turn,gameOver]);
      
      React.useEffect(()=>{if(pHP<=0)setGameOver('lose');else if(aHP<=0)setGameOver('win');},[pHP,aHP]);  
      const applyDamage=(target,dmg)=>{let field=target==='player'?pField:aField;const setField=target==='player'?setPF:setAF;const setHp=target==='player'?setP:setA;const idx=field.findIndex(c=>c.usable);if(idx>=0){const card=field[idx];const block=ELEMENTS.indexOf(card.el)+1;showToast(`æƒ°æ€§æ°£é«”é˜»æ“‹ ${block} é»å‚·å®³`);dmg=Math.max(0,dmg-block);setField(f=>f.filter((_,i)=>i!==idx));}setHp(h=>Math.max(0,h-dmg));};  

        //åˆæˆåˆ†å­å¸¸ç”¨æ–¹æ³•  handleCombine ----
      const handleCombine = () => {
        if (turn !== 'player' || gameOver) return;
        if (selEls.length < 2) { showToast('è«‹è‡³å°‘é¸2å¼µ'); return; }
        const cards = selEls.map(i => pHand[i]);
        if (cards.some(c => c.corroded)) { showToast('è…è•å¡ç„¡æ³•åˆæˆ'); return; }
        const m = findMol(cards);
        if (!m) { showToast('ç„¡æ³•åˆæˆ'); return; }
        // åˆæˆåˆ†å­
        const newMol = { ...m, id: Date.now() };  // â­ åŠ å…¥å”¯ä¸€ ID
      setPF(f => [newMol, ...f]);
      
   setJustUsedIndices(selEls);             // è¨˜éŒ„å‹•ç•«é–‹å§‹
setJustCombinedId(newMol.id);          // åˆæˆå‹•ç•«æ¨™è¨˜

setTimeout(() => {
  setJustUsedIndices([]);              // æ¸…é™¤å‹•ç•« class
  setJustCombinedId(null);             // æ¸…é™¤åˆæˆæ¨™è¨˜
  setPH(h => h.filter((_, i) => !selEls.includes(i)));  // â­ å»¶å¾Œç§»é™¤
}, 800);  // â±ï¸ å‹•ç•«çµæŸæ™‚é–“



MoleculeOnCombine(m, {
  sourceEls: selEls.map(i => pHand[i]),
  userId: 'player',
  opponentId: 'ai',
  applyDamage,
  addLog,
  showToast,
  triggerRecovery,
  opponentHand: aHand,
  setOpponentHand: setAH,
  setOpponentField: setAF
});



        setSelEls([]);
      };  
      const handleDiscard=()=>{if(turn!=='player'||gameOver)return; if(selEls.length<1){showToast('è«‹é¸æ“‡è¦æ£„ç‰Œ');return;}if(selEls.length>3){showToast('æœ€å¤šæ£„ç‰Œä¸‰å¼µ');return;}const names=selEls.map(i=>pHand[i].el).join(',');setPH(h=>h.filter((_,i)=>!selEls.includes(i)));addLog(`æ£„ç‰Œ: ${names}`);setSelEls([]);handleEnd();};  
      const handleEnd=()=>{if(gameOver)return;setSelEls([]);setSelMol(null);setTurn(t=>t==='player'?'ai':'player');addLog('çµæŸå›åˆ');};  
      const handleSelectEl=i=>{if(gameOver||turn!=='player')return;setSelMol(null);setSelEls(s=>s.includes(i)?s.filter(x=>x!==i):[...s,i]);};  
      
      //é¸æ“‡åˆ†å­  
      const handleSelectMol = (index) => {
        if (gameOver || turn !== 'player') return;
        setSelMol(index);
      };
           
      const handleSelectEnemyMol = (index) => {
        if (gameOver || turn !== 'player') return;
        setSelEnemyMol(index);
      };
      
        // é…¸é¹¼ä¸­å’Œçš„è™•ç†
const handleNeutralize = (myIndex, enemyIndex) => {
  const selectedMol = pField[myIndex];
  const enemyMol = aField[enemyIndex];

  if (!canNeutralize(selectedMol, enemyMol)) return;

  const key1 = `${selectedMol.name}+${enemyMol.name}`;
  const key2 = `${enemyMol.name}+${selectedMol.name}`;
  const saltName = NEUTRALIZATION_RECIPES[key1] || NEUTRALIZATION_RECIPES[key2];

  const salt = MOLECULES.find(m => m.name === saltName);
  const water = MOLECULES.find(m => m.name === "æ°´");

  if (!salt || !water) {
    showToast("ç„¡æ³•åˆ¤å®šä¸­å’Œç”¢ç‰©ï¼");
    return;
  }

  const saltMol = { ...salt, id: Date.now() };
  const waterMol = { ...water, id: Date.now() + 1 };

  // 1ï¸âƒ£ é›™æ–¹å„å—åˆ° 5 é»å‚·å®³
  applyDamage('player', 5);
  applyDamage('ai', 5);
  addLog(`é…¸é¹¼ä¸­å’Œé€ æˆé›™æ–¹å„ 5 é»å‚·å®³`);

  // 2ï¸âƒ£ å°æ‰‹é¡å¤–å—åˆ°é¹½é¡åˆ†å­å‚·å®³ï¼ˆä»¥åŸå­åºå’Œè¨ˆç®—ï¼‰
  const saltDamage = Object.entries(saltMol.formula || {}).reduce(
    (sum, [el, n]) => sum + (ELEMENTS.indexOf(el) + 1) * n, 0
  );
  applyDamage('ai', saltDamage);
  addLog(`é¹½é¡ ${saltMol.name} é¡å¤–é€ æˆ ${saltDamage} å‚·å®³`);

  // 3ï¸âƒ£ ç§»é™¤é›™æ–¹é…¸é¹¼åˆ†å­ â†’ æ”¾å…¥æ–°ç”Ÿæˆçš„é¹½èˆ‡æ°´
  setPF(f => [saltMol, waterMol, ...f.filter((_, i) => i !== myIndex)]);
  setAF(f => f.filter((_, i) => i !== enemyIndex));

  // æ¸…é™¤é¸æ“‡ç‹€æ…‹
  setSelMol(null);
  setSelEnemyMol(null);
  setCanCombine(false);

  // é¡¯ç¤ºè¨Šæ¯èˆ‡è§¸ç™¼æ°´çš„ç«‹å³å›è¡€
  showToast(`ä¸­å’ŒæˆåŠŸï¼ç”Ÿæˆ ${salt.name} å’Œ æ°´`);
  addLog(`ä¸­å’Œï¼š${selectedMol.name} + ${enemyMol.name} â†’ ${salt.name} + æ°´`);
  triggerRecovery('player', 'æ°´', 'immediate');
};



      
          React.useEffect(() => {
            if (selMol !== null && selEnemyMol !== null) {
              const selectedMol = pField[selMol];
              const enemyMol = aField[selEnemyMol];
              if (canNeutralize(selectedMol, enemyMol)) {
                setCanCombine(true);
              } else {
                setCanCombine(false);
              }
            } else {
              setCanCombine(false);
            }
          }, [selMol, selEnemyMol, pField, aField]);

      
      const hasWater = pField.some(m => m.name === 'æ°´') || aField.some(m => m.name === 'æ°´');
  
      
      const canUse = (turn === 'player' && !gameOver) && (
  // ç§»é™¤å°åˆ†å­ç‰Œçš„å•Ÿç”¨æ¢ä»¶
  selMol === null && 
  selEls.length === 1 && (
    pHand[selEls[0]].usable ||
    (ALKALI.includes(pHand[selEls[0]].el) && hasWater)
  )
);

      const handleUse = () => {
        if (turn !== 'player' || gameOver) return;
        if (selMol !== null) {
          const m = pField[selMol];
          addLog(`ä½¿ç”¨ åˆ†å­ ${m.name}`);
          const dmg = Object.entries(m.formula || {}).reduce(
            (s, [el, n]) => s + (ELEMENTS.indexOf(el) + 1) * n,
            0
          );
          applyDamage('ai', dmg);
          setPF((f) => f.filter((_, i) => i !== selMol));
          setSelMol(null);
        } else if (selEls.length === 1) {
          const idx = selEls[0];
          const card = pHand[idx];
          // ä½¿ç”¨ä»»ä½•å…ƒç´ å¡
        useElementCard(card, {
  userId: 'player',
  user: { field: pField },
  setUserHand: setPH,
  setUserField: setPF,
  opponentField: aField,
  setOpponentField: setAF,
  applyDamage,
  addLog,
  showToast
});

            setPH(h => h.filter((_, i) => i !== idx));

          setSelEls([]);
        }
        // çµæŸç©å®¶å›åˆ
        setTurn('ai');
      };  
      React.useEffect(() => {
  if (gameOver || turn !== 'ai') return;

        const newHand = drawCardsTo(aHand, setAH, 2, 'AI');
      //å¼·é…¸æŒçºŒ
       const hasStrongAcid = pField.some(m => (m.kind || '').includes('strong_acid'));
      if (hasStrongAcid) {
        const corroded = corrodeMetals(newHand, setAH, 1);
        if (corroded > 0) addLog(`ä½ æ–¹å¼·é…¸è…è•æ•µæ–¹ ${corroded} å¼µé‡‘å±¬å¡`);
      }
      //å¼·é¹¼æŒçºŒ
              const hasStrongBase = aField.some(m => (m.kind || '').includes('strong_base'));
      if (hasStrongBase) {
        setPF(prev => {
          const newField = [...prev];
          for (let i = 0; i < newField.length; i++) {
            const m = newField[i];
            if ((m.kind || '').includes('acid') || m.disabled) continue;
            newField[i] = { ...m, disabled: true };
            addLog(`æ•µæ–¹å¼·é¹¼æŒçºŒè®Šæ€§äº†ä½ æ–¹ ${m.name}`);
            break;
          }
          return newField;
        });
      }
      
      
        // å»¶é²åŸ·è¡Œè¡Œå‹•ï¼ˆçµ¦ React æ›´æ–°æ™‚é–“ï¼‰
        setTimeout(() => aiTakeAction(), 600);
      }, [turn, gameOver]);



 const possibleList = React.useMemo(() => {
  const cnt = {};
  pHand.filter(c => !c.corroded).forEach(c => {
    cnt[c.el] = (cnt[c.el] || 0) + 1;
  });

  return MOLECULES.filter(m =>
    Object.entries(m.formula || {}).every(([el, n]) => cnt[el] >= n)
  ).map(m =>
    `${m.name} (${Object.entries(m.formula).map(([el, n]) => n > 1 ? `${n}${el}` : el).join(' + ')})`
  );
}, [pHand]);

      const hintElements = React.useMemo(() => {
  const cnt = {};
  pHand.filter(c => !c.corroded).forEach(c => cnt[c.el] = (cnt[c.el] || 0) + 1);


  const hintSet = new Set();
  MOLECULES.forEach(m => {
    if (Object.entries(m.formula || {}).every(([el, n]) => cnt[el] >= n)) {
      Object.keys(m.formula).forEach(el => hintSet.add(el));
    }
  });
  return hintSet;
}, [pHand]);


      //uiå€åŸŸ-----------------------------------------------
      return(<div className="game-container"><div className="board">
        <h1>çœŸå¯¦ç…‰é‡‘ï¼šåŒ–åˆä¹‹æˆ°</h1>
        {aiThinking && (
  <div className="overlay">
    <div className="ai-text">AI æ€è€ƒä¸­...</div>
  </div>
)}
        <img src="https://wen91027.github.io/img/BN_top.jpeg" alt="éŠæˆ²é¦–åœ–" className="bg-logo" />


        {gameOver&&<div className="overlay"><h2>{gameOver==='win'?'ä½ è´äº†':'åŒ–å­¸ä¸æœƒå°±æ˜¯ä¸æœƒ'}</h2><button onClick={resetGame}>é‡æ–°é–‹å§‹</button></div>}
        <div className="zone">
  <div className="zone-title">å°æ‰‹æ‰‹ç‰Œ</div>
  <div className="hand enemy-hand">
{aHand.map((c, i) => (
 <div key={i}
  className={`card element ${c.usable ? 'inert' : ''}${ALKALI.includes(c.el) ? ' alkali' : ''}${c.corroded ? ' corroded' : ''}${aJustDrawnIndices.includes(i) ? ' just-drawn' : ''}`}>
       <div className="symbol">{c.el}</div>
        <div className="number">{ELEMENTS.indexOf(c.el) + 1}</div>
        {c.usable && <div className="defense">é˜²ç¦¦å‚·å®³</div>}
        {ALKALI.includes(c.el) && <div className="explode">å¼•çˆ†æ°´</div>}
      </div>
    ))}
  </div>
</div>
        <div className="hp-section"><span className="hp-label">AI HP</span><div className="hp-bar"><div className="hp-inner" style={{width:`${aHP/MAX_HP*100}%`}}/></div><span>{aHP}</span></div>

        {/* å°æ‰‹åˆ†å­å€ */}
        <div className="zone"><div className="zone-title">å°æ‰‹åˆ†å­å€</div><div className="field">
           {aField.map((c,i)=>
        <div key={i} className=
          {
          `card molecule
          ${c.effect}
          ${(c.kind || '').includes('acid') ? 'acid' : ''} 
          ${(c.kind || '').includes('base') ? 'base' : ''} 
          ${c.usable ? 'inert' : ''}
          ${c.disabled ? ' disabled' : ''}

          ${selEnemyMol === i ? ' selected' : ''}
          ${justCombinedId === c.id ? 'newly-created' : ''}
          
          `}onClick={() => handleSelectEnemyMol(i)}>
            
          
     {c.usable
      ? React.createElement(React.Fragment, null,
          React.createElement("div", { className: "symbol" }, c.el),
          React.createElement("div", { className: "block-info" }, `é˜»æ“‹${ELEMENTS.indexOf(c.el)+1}å‚·å®³`)
        )
      : React.createElement("div", { className: "name" }, c.name)
    }
    {c.effect === 'recover' && (
      <div className="recover-info">æŒçºŒå›å¾©{RECOVER_CONFIG['æ°´'].perTurn}HP</div>
    )}
    {c.effect === 'corrosion' && (
      <div className="corrosion-info">è…è•é‡‘å±¬</div>
    )}

    {c.effect === 'alkali' && (
    <div className="alkali-info">è®Šæ€§åˆ†å­</div>
  )}

  </div>
        )}</div></div>

        {/* logå€ */}
        <div className="log">{log.slice(0,5).map((l,i)=>
          <div key={i} style={{color:i===0?'#ff0':'#ccc'}}>{l}</div>
        )}</div>


        {/* æˆ‘æ–¹åˆ†å­å€ */}
        <div className="zone"><div className="zone-title">æˆ‘æ–¹åˆ†å­å€</div><div className="field">
          {pField.map((c,i)=>
          <div key={i} className={`card molecule
          ${c.effect}
          ${(c.kind || '').includes('acid') ? 'acid' : ''} 
          ${(c.kind || '').includes('base') ? 'base' : ''} 
          ${c.usable ? 'inert' : ''}
          ${c.disabled ? ' disabled' : ''}

          
          ${selMol === i ? ' selected' : ''}
          ${justCombinedId === c.id ? 'newly-created' : ''}
          `} onClick={() => handleSelectMol(i)}> 
            
            {c.usable
              ? React.createElement(React.Fragment, null,
                  React.createElement("div", { className: "symbol" }, c.el),
                  React.createElement("div", { className: "block-info" }, `é˜»æ“‹${ELEMENTS.indexOf(c.el)+1}å‚·å®³`)
                )
              : React.createElement("div", { className: "name" }, c.name)
            }
                    {c.effect === 'recover' &&
          <div className="recover-info">
            æŒçºŒå›å¾©{RECOVER_CONFIG['æ°´'].perTurn}HP
          </div>
        }
              {c.effect === 'corrosion' && (
    <div className="corrosion-info">è…è•é‡‘å±¬</div>
  )}
             {c.effect === 'alkali' && (
    <div className="alkali-info">è®Šæ€§åˆ†å­</div>
  )}
            
          </div>
        )}</div></div>

          <div>
      <div>
        {/* å¦‚æœå¯ä»¥ä¸­å’Œï¼Œé¡¯ç¤ºåˆæˆæŒ‰éˆ• */}
 {selMol !== null && selEnemyMol !== null && (
<button 
  onClick={() => handleNeutralize(selMol, selEnemyMol)}
  disabled={!canCombine}
>
    ä¸­å’Œ
  </button>
)}
      </div>
    </div>
<div className="floating-container">
        <div className="floating-ui">
         <div className="zone"> <div className="zone-title">ç©å®¶å€åŸŸ</div>
             <div className="hp-section">
              <div className="hp-label">ç©å®¶ HP</div>
              <div className="hp-bar"><div className="hp-inner" style={{width:`${pHP/MAX_HP*100}%`}}/></div>
              <div className="hp-text">{pHP}</div>
            </div>

        
          <div className="hand">{pHand.map((c,i)=>
 <div key={i}
  className={`card element ${c.usable ? 'inert' : ''}${ALKALI.includes(c.el) ? ' alkali' : ''}${c.corroded ? ' corroded' : ''}${selEls.includes(i) ? ' selected' : ''}${pJustDrawnIndices.includes(i) ? ' just-drawn': ''}${justUsedIndices.includes(i) ? ' combine-out' : ''}${hintElements.has(c.el) ? ' hint-glow' : ''}
`}
  onClick={() => handleSelectEl(i)}>
            <div className="symbol">{c.el}</div>
            <div className="number">{ELEMENTS.indexOf(c.el)+1}</div>
            {c.usable&&<div className="defense">é˜²ç¦¦å‚·å®³</div>}
            {ALKALI.includes(c.el)&&<div className="explode">å¼•çˆ†æ°´</div>}
          </div>
        )}</div></div>
        <div className="prompt">{possibleList.length>0?`å¯åˆæˆ: ${possibleList.join('ã€')}`:'ç„¡å¯åˆæˆåŒ–åˆç‰©'}</div>
        </div>
        <div className="controls grid-controls">
  
          <button onClick={handleCombine} disabled={turn!=='player'||gameOver||selEls.length<2}>åˆæˆ</button>
          <button onClick={handleUse} disabled={!canUse}>ä½¿ç”¨</button>
          <button onClick={handleDiscard} disabled={turn!=='player'||gameOver||selEls.length<1}>æ£„ç‰Œ</button>
          <button onClick={handleEnd} disabled={turn!=='player'||gameOver}>çµæŸå›åˆ</button>
         </div>
        
    
  
  </div>
         </div></div>);
    }
    ReactDOM.render(<App/>,document.getElementById('root'));
  </script>
</body>
</html>



