<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>真實煉金：化合之戰</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400&display=swap" rel="stylesheet" />
  <style>
    body { margin:0; background:#0d1321; color:#fff; font-family:'Orbitron',sans-serif; text-align:center; }
    .toast { position:fixed; top:150px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); color:#f55; padding:8px 16px; border:1px solid #f55; border-radius:4px; z-index:2000; opacity:0; transition:opacity 0.3s; }
    .toast.show { opacity:1; }
    .game-container { display:flex; flex-direction:column; align-items:center; padding:1em; }
    .board { width:90%; max-width:800px; background:#1a242f; border:2px solid #444; border-radius:10px; padding:1em; position:relative; }
    .overlay { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:1000; }
    .overlay button { margin-top:1em; }
    .hp-section { display:flex; align-items:center; justify-content:center; margin:8px 0; }
    .hp-label { margin-right:8px; }
    .hp-bar { flex:1; background:#222; border:1px solid #0ff; border-radius:4px; height:16px; margin:0 8px; overflow:hidden; }
    .hp-inner { background:#0ff; height:100%; }
    .zone { margin:12px 0; }
    .zone-title { color:#ccc; margin-bottom:4px; }
    .hand { display:flex; flex-wrap:wrap; justify-content:center; }
    .field { display:flex; flex-wrap:nowrap; justify-content:flex-start; overflow-x:auto; }
    .card { border:1px solid #555; border-radius:6px; padding:6px; margin:4px; transition:transform .2s; display:flex; flex-direction:column; align-items:center; }
    .card:hover { transform:translateY(-4px); }
    .card.element { width:50px; height:70px; background:#1f2a36; cursor:pointer; position:relative; }
    .card.element.inert { background:#555; }
    .card.element.alkali { background:#a00; }
    .card.element .symbol {  font-size: 1.2em;
  margin-top: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex: 1; /* 讓它撐滿父元素高度，便於置中 */}
    .card.element .number { position:absolute; top:4px; right:6px; font-size:0.8em; color:#0ff; }
    .card.element .defense { position:absolute; bottom:4px; width:100%; font-size:0.6em; color:#fff; text-align:center; }
    .card.element .explode { position:absolute; bottom:4px; width:100%; font-size:0.6em; color:#ff0; text-align:center; }
    .card.element.selected { border-color:#0f0; box-shadow:0 0 6px #0f0; }
    .card.element.corroded { background: linear-gradient(45deg, #555 25%, #333 25%, #333 50%, #555 50%, #555 75%, #333 75%, #333 100%); background-size: 6px 6px;position: relative;}
    .card.element.corroded::after {content: "腐蝕";position: absolute;top: 2px;left: 50%;transform: translateX(-50%);font-size: 0.4em;color: #ff6688;}
    
    .card.molecule { width:80px; min-height:60px; background:#14232e; cursor:pointer; position:relative; }
    /* effect-specific backgrounds */
    .card.molecule.corrosion { background:#661100; }
    .card.molecule.poison    { background:#440066; }
    .card.molecule.burn      { background:#663300; }
    .card.molecule.recover   { background:#00AEAE; border:2px solid #fff; box-shadow:0 0 8px #fff;}
    .card.molecule.inert     { background:#555; border:2px solid #fff; box-shadow:0 0 8px #fff; pointer-events:none; display:flex; flex-direction:column; justify-content:center; align-items:center; }
    .card.molecule.inert .symbol    { font-size:1em; margin:4px 0; }
    .card.molecule.inert .block-info { font-size:0.8em; color:#fff; }
    .card.molecule.recover .symbol     { font-size:1em; margin-top:8px; }
    .card.molecule.recover .recover-info { position:absolute; bottom:4px; width:100%; font-size:0.6em; color:#fff; text-align:center; }
    .card.molecule.acid {  background: #BF0060;}
    .card.molecule.corrosion .corrosion-info {
  position: absolute;
  bottom: 4px;
  width: 100%;
  font-size: 0.6em;
  color: #ff6688; /* 比較偏粉紅紅色 */
  text-align: center;
  font-weight: bold;
}
    
    .card.molecule.selected { border:2px solid #0f0; box-shadow:0 0 6px #0f0; }
    .controls { margin:8px 0; }
    button { font-family:'Orbitron',sans-serif; background:#112233; color:#0ff; border:1px solid #0ff; border-radius:4px; padding:6px 12px; margin:0 4px; cursor:pointer; transition:background 0.2s; }
    button:hover:enabled { background:#334455; }
    button:disabled { opacity:0.5; cursor:not-allowed; }
    .prompt { color:#8cf; margin-top:4px; }
    .log { text-align:center; max-height:120px; overflow-y:auto; background:#112233; padding:8px; border:1px solid #333; border-radius:4px; margin-top:8px; font-size:1em; }
    .enemy-hand .card { opacity: 0.6;  pointer-events: none;}
    @media (orientation: portrait) {
    .board { width:100%; padding:0.5em; }
    .hp-section { flex-direction: column; }
    .hp-label, .hp-text { margin: 2px 0; }
    .hp-bar { flex: none !important; width: 100% !important; margin: 4px 0; }
    .zone-title { font-size: 0.9em; }
    .hand { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 0.25em; }
    .field { display: flex; flex-wrap: nowrap; overflow-x: auto; padding-bottom: 4px; }
    .card { margin: 2px; padding: 4px; min-width: 60px; }
    .card.element { width: auto; height: 60px; }
    .card.molecule { width: auto; min-height: 50px; }
    button { width: 100%; margin: 4px 0; padding: 8px; }
    .controls { flex-direction: column; }
    .prompt, .log { font-size: 0.8em; }
  }
    .hp-section { flex-direction: column; }
    .hp-label, .hp-text { margin: 2px 0; }
    .hp-bar { flex: none !important; width: 100% !important; margin: 4px 0; }
    .zone-title { font-size: 0.9em; }
    .hand, .field { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 0.25em; }
    .card { margin: 2px; padding: 4px; min-width: 60px; }
    .card.element { width: auto; height: 60px; }
    .card.molecule { width: auto; min-height: 50px; }
    button { width: 100%; margin: 4px 0; padding: 8px; }
    .controls { flex-direction: column; }
    .prompt, .log { font-size: 0.8em; }
    .bg-logo {
  width: 100%;
  max-width: 100%;
  height: auto;
  display: block;
  margin: 0 auto 1em;
}

   /* 動畫效果新增在這 */

    /* AI思考遮罩 */
.ai-text {font-size: 1.5em;color: #0ff;animation: pulse 1s infinite;text-shadow: 0 0 10px #0ff;}

@keyframes pulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.6; }
  100% { transform: scale(1); opacity: 1; }
}

/* 牌從上往下飛並淡入 */
    
@keyframes slide-down {
  0% {transform: translateY(-100px);opacity: 0;}
  100% {transform: translateY(0);opacity: 1;}
}
/* 剛合成的牌 */
.card.molecule.newly-created { animation: slide-down 0.6s ease-out;}
/* 新的飛入動畫 */
@keyframes fly-in {
  0% {
    transform: translateY(-80px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
}

 /* 合成動畫：分子 */
.card.molecule.just-combined {
  animation: fly-in 0.5s ease-out;
  z-index: 10;
}

/* 抽卡動畫：元素 */
.card.element.just-drawn {
  animation: fly-in 0.5s ease-out;
  z-index: 10;
}
/* 合成動畫：元素 */
    .card.element.combine-out {
  animation: combine-out 0.5s ease-in-out forwards;
}

@keyframes combine-out {
  0%   { transform: scale(1) translateY(0); opacity: 1; }
  100% { transform: scale(0.2) translateY(-40px); opacity: 0; }
}

/* 合成動畫：特效光 */
    
.card.molecule.flash {
  position: relative;
}

.card.molecule.flash::after {
  content: "";
  position: absolute;
  top: -6px;
  left: -6px;
  width: calc(100% + 12px);
  height: calc(100% + 12px);
  border-radius: 10px;
  border: 2px solid rgba(255, 255, 255, 0.8);
  animation: flash-glow 0.8s ease-out;
  pointer-events: none;
  z-index: 999;
}

@keyframes flash-glow {
  0% { box-shadow: 0 0 0px #fff; transform: scale(1); }
  50% { box-shadow: 0 0 20px #fff; transform: scale(1.05); }
  100% { box-shadow: 0 0 0px #fff; transform: scale(1); }
  z-index: 999;
}

    .card.molecule.newly-created {
  animation: flash-glow 0.6s ease-out;
      z-index: 999;
}
    
  }
  </style>
  
      </head>
<body>
  <div id="toast" class="toast"></div>
  <div id="root"></div>
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <script type="text/babel">
    const MAX_HP = 128;
    const ELEMENTS = ["H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca"];
    const ALKALI = ["Li","Na","K"]; // 1A族
    const METALS = ["Li", "Na", "K", "Be", "Mg", "Ca", "Al"]; // 金屬元素
    const WEIGHTS = {H:16,C:10,O:12,N:8,Na:5,He:2,Ne:1,Ar:0.5};
    const drawPool = [];
    ELEMENTS.forEach(e => {
      const w = WEIGHTS[e]||3;
      for (let i=0;i<Math.round(w*2);i++) drawPool.push(e);
    });
    function drawCard(){
      const el = drawPool[Math.floor(Math.random()*drawPool.length)];
      return { el, corroded:false, usable:['He','Ne','Ar'].includes(el) };
    }
    const MOLECULES = [
      { name: "一氧化氮",  formula: { N: 1, O: 1 },        kind: "none",         effect: "poison"     },
  { name: "一氧化碳",  formula: { C: 1, O: 1 },        kind: "none",         effect: "poison"     },
  { name: "乙炔",      formula: { C: 2, H: 2 },        kind: "organic",      effect: "burn"       },
  { name: "乙烯",      formula: { C: 2, H: 4 },        kind: "organic",      effect: "burn"       },
  { name: "二氧化碳",  formula: { C: 1, O: 2 },        kind: "none",         effect: "none"       },
  { name: "水",        formula: { H: 2, O: 1 },        kind: "none",         effect: "recover"    },
  { name: "甲烷",      formula: { C: 1, H: 4 },        kind: "organic",      effect: "burn"       },
  { name: "光氣",      formula: { C: 1, O: 1, Cl: 2 }, kind: "organic",      effect: "poison"     },
  { name: "氟化鈉",    formula: { Na: 1, F: 1 },       kind: "salt",         effect: "none"       },
  { name: "氟化鈹",    formula: { Be: 1, F: 2 },       kind: "salt",         effect: "none"       },
  { name: "氟化鉀",    formula: { K: 1, F: 1 },        kind: "salt",         effect: "none"       },
  { name: "氟化鋁",    formula: { Al: 1, F: 3 },       kind: "salt",         effect: "none"       },
  { name: "氟化鋰",    formula: { Li: 1, F: 1 },       kind: "salt",         effect: "none"       },
  { name: "氟化鎂",    formula: { Mg: 1, F: 2 },       kind: "salt",         effect: "none"       },
  { name: "氧化鈉",    formula: { Na: 2, O: 1 },       kind: "salt",         effect: "none"       },
  { name: "氧化鈣",    formula: { Ca: 1, O: 1 },       kind: "salt",         effect: "none"       },
  { name: "氧化鈹",    formula: { Be: 1, O: 1 },       kind: "salt",         effect: "none"       },
  { name: "氧化鉀",    formula: { K: 2, O: 1 },        kind: "salt",         effect: "none"       },
  { name: "氧化鋁",    formula: { Al: 2, O: 3 },       kind: "salt",         effect: "none"       },
  { name: "氧化鋰",    formula: { Li: 2, O: 1 },       kind: "salt",         effect: "none"       },
  { name: "氧化鎂",    formula: { Mg: 1, O: 1 },       kind: "salt",         effect: "none"       },
  { name: "氧氣",      formula: { O: 2 },             kind: "none",         effect: "none"       },
  { name: "臭氧",      formula: { O: 3 },             kind: "none",         effect: "poison"     },
  { name: "氫氟酸",    formula: { H: 1, F: 1 },       kind: "strong_acid",  effect: "corrosion" },
  { name: "氫氣",      formula: { H: 2 },             kind: "none",         effect: "none"       },
  { name: "氫氧化鈉",  formula: { Na: 1, O: 1, H: 1},  kind: "strong_base", effect: "alkali"    },
  { name: "氫氧化鈣",  formula: { Ca: 1, O: 2, H: 2},  kind: "base",        effect: "alkali"    },
  { name: "氫氧化鉀",  formula: { K: 1, O: 1, H: 1},  kind: "strong_base", effect: "alkali"    },
  { name: "氫氧化鋁",  formula: { Al: 1, O: 3, H: 3},  kind: "none",         effect: "none"       },
  { name: "氫氧化鋰",  formula: { Li: 1, O: 1, H: 1},  kind: "strong_base", effect: "alkali"    },
  { name: "氫氧化鎂",  formula: { Mg: 1, O: 2, H: 2},  kind: "base",        effect: "alkali"    },
  { name: "氮化鈉",    formula: { Na: 3, N: 1 },       kind: "salt",         effect: "none"       },
  { name: "氮化鉀",    formula: { K: 3, N: 1 },        kind: "salt",         effect: "none"       },
  { name: "氮化鋁",    formula: { Al: 1, N: 1 },       kind: "salt",         effect: "none"       },
  { name: "氮化鋰",    formula: { Li: 3, N: 1 },       kind: "salt",         effect: "none"       },
  { name: "氮氣",      formula: { N: 2 },             kind: "none",         effect: "none"       },
  { name: "氯化鈉",    formula: { Na: 1, Cl: 1 },      kind: "salt",         effect: "none"       },
  { name: "氯化鈹",    formula: { Be: 1, Cl: 2 },      kind: "salt",         effect: "none"       },
  { name: "氯化鉀",    formula: { K: 1, Cl: 1 },       kind: "salt",         effect: "none"       },
  { name: "氯化鋁",    formula: { Al: 1, Cl: 3 },      kind: "salt",         effect: "none"       },
  { name: "氯化鋰",    formula: { Li: 1, Cl: 1 },      kind: "salt",         effect: "none"       },
  { name: "氯化鎂",    formula: { Mg: 1, Cl: 2 },      kind: "salt",         effect: "none"       },
  { name: "氯仿",      formula: { C: 1, H: 1, Cl: 3},  kind: "organic",      effect: "poison"     },
  { name: "氯氣",      formula: { Cl: 2 },            kind: "none",         effect: "poison"     },
  { name: "氰酸",      formula: { H: 1, C: 1, N: 1, O: 1}, kind: "acid",      effect: "corrosion" },
  { name: "硝酸",      formula: { H: 1, N: 1, O: 3},  kind: "strong_acid", effect: "corrosion" },
  { name: "硫化鈉",    formula: { Na: 2, S: 1 },       kind: "salt",         effect: "none"       },
  { name: "硫化鈹",    formula: { Be: 1, S: 1 },       kind: "salt",         effect: "none"       },
  { name: "硫化鉀",    formula: { K: 2, S: 1 },        kind: "salt",         effect: "none"       },
  { name: "硫化鋁",    formula: { Al: 2, S: 3 },       kind: "salt",         effect: "none"       },
  { name: "硫化鋰",    formula: { Li: 2, S: 1 },       kind: "salt",         effect: "none"       },
  { name: "硫化鎂",    formula: { Mg: 1, S: 1 },       kind: "salt",         effect: "none"       },
  { name: "硫酸",      formula: { H: 2, S: 1, O: 4},  kind: "strong_acid", effect: "corrosion" },
  { name: "溴化鈉",    formula: { Na: 1, Br: 1 },      kind: "salt",         effect: "none"       },
  { name: "溴化鉀",    formula: { K: 1, Br: 1 },       kind: "salt",         effect: "none"       },
  { name: "溴化鋰",    formula: { Li: 1, Br: 1 },      kind: "salt",         effect: "none"       },
  { name: "溴化鎂",    formula: { Mg: 1, Br: 2 },      kind: "salt",         effect: "none"       },
  { name: "碘化鈉",    formula: { Na: 1, I: 1 },       kind: "salt",         effect: "none"       },
  { name: "碘化鉀",    formula: { K: 1, I: 1 },        kind: "salt",         effect: "none"       },
  { name: "碳化矽",    formula: { C: 1, Si: 1 },       kind: "none",         effect: "poison"     },
  { name: "磷化鈉",    formula: { Na: 3, P: 1 },       kind: "salt",         effect: "none"       },
  { name: "磷化鉀",    formula: { K: 3, P: 1 },        kind: "salt",         effect: "none"       },
  { name: "磷化鋁",    formula: { Al: 1, P: 1 },       kind: "salt",         effect: "none"       },
  { name: "磷化鋰",    formula: { Li: 3, P: 1 },       kind: "salt",         effect: "none"       },
  { name: "鹽酸",      formula: { H: 1, Cl: 1 },      kind: "strong_acid",  effect: "corrosion" }
    ];
    function findMol(sel){
      const cnt={}; sel.forEach(c=>c&&c.el&&(cnt[c.el]=(cnt[c.el]||0)+1));
      for(const m of MOLECULES){ const f=m.formula;
        if(Object.values(f).reduce((a,b)=>a+b,0)!==sel.length) continue;
        let ok=true; for(const k in f) if(cnt[k]!==f[k]) ok=false;
        for(const k in cnt) if(!f[k]) ok=false;
        if(ok) return m;
      }
      return null;
    }

    
//腐蝕相關函式
function corrodeMetals(hand, setHand, count = 2) {  // <--- 加一個 count = 2 預設
  const metals = METALS;
  const metalIndices = hand
    .map((c, i) => (metals.includes(c.el) && !c.corroded ? i : -1))
    .filter(i => i !== -1);

  if (metalIndices.length > 0) {
    const shuffle = [...metalIndices].sort(() => Math.random() - 0.5);
    const selected = shuffle.slice(0, Math.min(count, shuffle.length));
    const newHand = [...hand];
    selected.forEach(i => newHand[i] = { ...newHand[i], corroded: true });
    setHand(newHand);
    return selected.length;
  }
  return 0;
}
//清除腐蝕
    function clearCorrosion(hand, setHand) {
  const newHand = hand.map(c => c.corroded ? { ...c, corroded: false } : c);
  setHand(newHand);
}
    
    function showToast(msg){const t=document.getElementById('toast');t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),2000);}
    
  

    //APP 主要遊戲段落-----------------------------------------------
    function App(){

        // 其餘狀態鉤子與函式...
      const [turn,setTurn]=React.useState('player');
      const [pHP,setP]=React.useState(MAX_HP);
      const [aHP,setA]=React.useState(MAX_HP);
      const [pHand,setPH]=React.useState([]);
      const [aHand,setAH]=React.useState([]);
      const [pField,setPF]=React.useState([]);
      const [aField,setAF]=React.useState([]);
      const [selEls,setSelEls]=React.useState([]);
      const [selMol,setSelMol]=React.useState(null);
      const [log,setLog]=React.useState([]);
      const [gameOver,setGameOver]=React.useState(null);
      const firstDraw=React.useRef(true);
      const [aiThinking, setAiThinking] = React.useState(false);
      const addLog=msg=>setLog(l=>[msg,...l]);
      const resetGame=()=>{setP(MAX_HP);setA(MAX_HP);setPH(Array.from({length:5},drawCard));setAH(Array.from({length:5},drawCard));setPF([]);setAF([]);setSelEls([]);setSelMol(null);setLog([]);setGameOver(null);setTurn('player');firstDraw.current=true;addLog('遊戲重置，玩家先手');};
      const [justCombinedId, setJustCombinedId] = React.useState(null);
      const [justDrawnIndices, setJustDrawnIndices] = React.useState([]);
      const [justUsedIndices, setJustUsedIndices] = React.useState([]);
//酸鹼//////////////////////////////////////////////////
// 計算玩家能否進行酸鹼中和
const [canCombine, setCanCombine] = React.useState(false);
      const [selEnemyMol, setSelEnemyMol] = React.useState(null);
      
const canNeutralize = (selectedMol, enemyMol) => {
  return selectedMol && enemyMol && 
    (
      ((selectedMol.kind || '').includes('base') && (enemyMol.kind || '').includes('acid')) ||
      ((selectedMol.kind || '').includes('acid') && (enemyMol.kind || '').includes('base'))
    );
};


      ////////////////////////////////////////

      
      //抽牌通用
function drawCardsTo(currentHand, setHand, count = 2, label = '玩家') {
  const newCards = Array.from({ length: count }, drawCard);
  const updatedHand = [...currentHand, ...newCards];
  setHand(updatedHand);
  addLog(`${label}抽${count}張`);
  
if (label === '玩家' || label === 'AI') {
const startIndex = currentHand.length;
const indices = newCards.map((_, i) => startIndex + i);
setJustDrawnIndices(indices);   // 共用動畫 index
setTimeout(() => setJustDrawnIndices([]), 800);
}


  return updatedHand;
}

      
      // 回復配置：分子即時與每回合回血
      const RECOVER_CONFIG = {
        '水': { immediate: 7, perTurn: 1 },
        // 如需其他分子回血，可在此新增
      };
      // 通用回血觸發函式
      const triggerRecovery = (target, molName, trigger) => {
        const cfg = RECOVER_CONFIG[molName];
        if (!cfg || !cfg[trigger]) return;
        const heal = cfg[trigger];
        const setter = target === 'player' ? setP : setA;
        setter(hp => Math.min(MAX_HP, hp + heal));
        addLog(`${molName}${trigger==='immediate'? ' 合成回復':' 每回合回復'} ${heal} HP`);
      };
      
      //aiTakeAction() AI動作
  async function aiTakeAction() {
    setAiThinking(true);  // 開始顯示遮罩
    await new Promise(resolve => setTimeout(resolve, 600)); // 👈 關鍵：讓 UI 有機會重繪
  let hand = [...aHand];
  let field = [...aField];
  const sumAtoms = f => Object.entries(f).reduce((s, [el, n]) => s + (ELEMENTS.indexOf(el) + 1) * n, 0);

  const possible = MOLECULES.filter(m => {
    const cnt = {};
    hand.forEach(c => cnt[c.el] = (cnt[c.el] || 0) + 1);
    return Object.entries(m.formula || {}).every(([el, n]) => cnt[el] >= n);
  });

  if (possible.length > 0 && Math.random() >= 0.3) {
    possible.sort((a, b) => sumAtoms(b.formula) - sumAtoms(a.formula));
    const m = possible[0];
    const used = [];

    Object.entries(m.formula).forEach(([el, n]) => {
      for (let i = hand.length - 1; i >= 0 && n > 0; i--) {
        if (hand[i].el === el) {
          used.push(el);
          hand.splice(i, 1);
          n--;
        }
      }
    });

    setAH([...hand]); // 🔥 手牌同步
    setAF(f => [m, ...f]); // 分子區同步
    addLog(`AI 合成 ${m.name}`);

    if ((m.kind || '').includes('acid')) {
      const corroded = corrodeMetals(pHand, setPH);
      if (corroded > 0) addLog(`敵方酸性分子腐蝕了你 ${corroded} 張金屬卡`);
    }

    const dmg = used.reduce((s, el) => s + (ELEMENTS.indexOf(el) + 1), 0);
    applyDamage('player', dmg);
    addLog(`你受到 ${dmg} 傷`);

    let continueAction = true;
while (continueAction) {
  await new Promise(resolve => setTimeout(resolve, 600)); // 延遲 0.6 秒

  const currentHand = [...hand]; // 最新手牌
  const cnt = {};
  currentHand.forEach(c => cnt[c.el] = (cnt[c.el] || 0) + 1);

  const possible = MOLECULES.filter(m =>
    Object.entries(m.formula || {}).every(([el, n]) => cnt[el] >= n)
  );

  if (possible.length > 0 && Math.random() > 0.5) { // 機率決定是否連續出手
    possible.sort((a, b) => sumAtoms(b.formula) - sumAtoms(a.formula));
    const m = possible[0];

    const used = [];
    Object.entries(m.formula).forEach(([el, n]) => {
      for (let i = hand.length - 1; i >= 0 && n > 0; i--) {
        if (hand[i].el === el) {
          used.push(el);
          hand.splice(i, 1);
          n--;
        }
      }
    });

    setAH([...hand]);
    setAF(f => [m, ...f]);
    addLog(`AI 合成 ${m.name}`);

    if ((m.kind || '').includes('acid')) {
      const corroded = corrodeMetals(pHand, setPH);
      if (corroded > 0) addLog(`敵方酸性分子腐蝕了你 ${corroded} 張金屬卡`);
    }

    const dmg = used.reduce((s, el) => s + (ELEMENTS.indexOf(el) + 1), 0);
    applyDamage('player', dmg);
    addLog(`你受到 ${dmg} 傷`);
  } else {
    continueAction = false;
  }
}

handleEnd();
  } else {
    if (Math.random() < 0.5) {
      addLog('AI 選擇結束回合');
    } else {
      let toDiscard = hand.length > 8 ? 3 : hand.length > 5 ? 2 : 1;
      const idxs = [];
      while (idxs.length < toDiscard && hand.length > 0) {
        const i = Math.floor(Math.random() * hand.length);
        if (!idxs.includes(i)) idxs.push(i);
      }
      const names = idxs.map(i => hand[i].el).join(',');
      idxs.sort((a, b) => b - a).forEach(i => hand.splice(i, 1));
      setAH([...hand]);
      addLog(`AI 棄牌: ${names}`);
    }

    handleEnd(); // 確實結束回合
  }
    setAiThinking(false); // 動作結束後關掉遮罩
}

          React.useEffect(()=>resetGame(),[]);
      React.useEffect(()=>{if(gameOver) return; if(firstDraw.current){firstDraw.current=false;return;} 
        if (turn === 'player') {
const newHand = drawCardsTo(pHand, setPH, 2, '玩家');

const acidCount = aField.filter(m => (m.kind || '').includes('acid')).length;
const strongAcidCount = aField.filter(m => (m.kind || '').includes('strong_acid')).length;

if (acidCount === 0) clearCorrosion(newHand, setPH);
if (strongAcidCount > 0) {
  const corroded = corrodeMetals(newHand, setPH, 1);
  if (corroded > 0) addLog(`敵方強酸腐蝕了你 ${corroded} 張金屬卡`);
}

          // 水分子每回合回復
          const waterCount = pField.filter(m => m.name==='水').length;
          if(waterCount>0){
            const heal = waterCount * RECOVER_CONFIG['水'].perTurn;
            setP(h=>Math.min(MAX_HP, h + heal));
            addLog(`每回合回復 ${heal} HP`);
          }}
      
                          },[turn,gameOver]);
      React.useEffect(()=>{if(pHP<=0)setGameOver('lose');else if(aHP<=0)setGameOver('win');},[pHP,aHP]);  
      const applyDamage=(target,dmg)=>{let field=target==='player'?pField:aField;const setField=target==='player'?setPF:setAF;const setHp=target==='player'?setP:setA;const idx=field.findIndex(c=>c.usable);if(idx>=0){const card=field[idx];const block=ELEMENTS.indexOf(card.el)+1;showToast(`惰性氣體阻擋 ${block} 點傷害`);dmg=Math.max(0,dmg-block);setField(f=>f.filter((_,i)=>i!==idx));}setHp(h=>Math.max(0,h-dmg));};  

        //合成分子常用方法  handleCombine ----
      const handleCombine = () => {
        if (turn !== 'player' || gameOver) return;
        if (selEls.length < 2) { showToast('請至少選2張'); return; }
        const cards = selEls.map(i => pHand[i]);
        if (cards.some(c => c.corroded)) { showToast('腐蝕卡無法合成'); return; }
        const m = findMol(cards);
        if (!m) { showToast('無法合成'); return; }
        // 合成分子
        const newMol = { ...m, id: Date.now() };  // ⭐ 加入唯一 ID
      setPF(f => [newMol, ...f]);
      
   setJustUsedIndices(selEls);             // 記錄動畫開始
setJustCombinedId(newMol.id);          // 合成動畫標記

setTimeout(() => {
  setJustUsedIndices([]);              // 清除動畫 class
  setJustCombinedId(null);             // 清除合成標記
  setPH(h => h.filter((_, i) => !selEls.includes(i)));  // ⭐ 延後移除
}, 800);  // ⏱️ 動畫結束時間

        addLog(`合成 ${m.name}`);


// 合成酸
        
if ((m.kind || '').includes('acid')) {
  const corroded = corrodeMetals(aHand, setAH);
  if (corroded > 0) addLog(`酸性分子腐蝕了敵方 ${corroded} 張金屬卡`);
}        
        // 傷害計算
        const dmg = selEls.reduce((s, i) => s + (ELEMENTS.indexOf(pHand[i].el) + 1), 0);
        applyDamage('ai', dmg);
        // 合成水時立即回血
        if (m.name === '水') {
          triggerRecovery('player', '水', 'immediate');
          showToast(`合成水，回復 ${RECOVER_CONFIG['水'].immediate} HP`);
        }
        setSelEls([]);
      };  
      const handleDiscard=()=>{if(turn!=='player'||gameOver)return; if(selEls.length<1){showToast('請選擇要棄牌');return;}if(selEls.length>3){showToast('最多棄牌三張');return;}const names=selEls.map(i=>pHand[i].el).join(',');setPH(h=>h.filter((_,i)=>!selEls.includes(i)));addLog(`棄牌: ${names}`);setSelEls([]);handleEnd();};  
      const handleEnd=()=>{if(gameOver)return;setSelEls([]);setSelMol(null);setTurn(t=>t==='player'?'ai':'player');addLog('結束回合');};  
      const handleSelectEl=i=>{if(gameOver||turn!=='player')return;setSelMol(null);setSelEls(s=>s.includes(i)?s.filter(x=>x!==i):[...s,i]);};  
      
        
      const handleSelectMol = (index) => {
        if (gameOver || turn !== 'player') return;
        setSelMol(index);
      };
           
      const handleSelectEnemyMol = (index) => {
        if (gameOver || turn !== 'player') return;
        setSelEnemyMol(index);
      };
        // 合成的處理
        const handleNeutralize = (selectedMol, enemyMol) => {
          if (!canNeutralize(selectedMol, enemyMol)) return;
        
          // 當中和成功，更新分子區、生命值等狀態
          setPF((f) => [...f, { ...selectedMol, effect: 'neutralized' }]);
          setAF((f) => f.filter((mol) => mol !== enemyMol)); // 移除被中和的敵方分子
        
          // 顯示成功信息
          showToast(`中和成功！${selectedMol.name} 和 ${enemyMol.name} 合成`);
          addLog(`成功中和 ${enemyMol.name}`);
        };
          React.useEffect(() => {
            if (selMol !== null && selEnemyMol !== null) {
              const selectedMol = pField[selMol];
              const enemyMol = aField[selEnemyMol];
              if (canNeutralize(selectedMol, enemyMol)) {
                setCanCombine(true);
              } else {
                setCanCombine(false);
              }
            } else {
              setCanCombine(false);
            }
          }, [selMol, selEnemyMol, pField, aField]);

      
      const hasWater = pField.some(m => m.name === '水') || aField.some(m => m.name === '水');
  
      
      const canUse = (turn === 'player' && !gameOver) && (
  // 移除對分子牌的啟用條件
  selMol === null && 
  selEls.length === 1 && (
    pHand[selEls[0]].usable ||
    (ALKALI.includes(pHand[selEls[0]].el) && hasWater)
  )
);

      const handleUse = () => {
        if (turn !== 'player' || gameOver) return;
        if (selMol !== null) {
          const m = pField[selMol];
          addLog(`使用 分子 ${m.name}`);
          const dmg = Object.entries(m.formula || {}).reduce(
            (s, [el, n]) => s + (ELEMENTS.indexOf(el) + 1) * n,
            0
          );
          applyDamage('ai', dmg);
          setPF((f) => f.filter((_, i) => i !== selMol));
          setSelMol(null);
        } else if (selEls.length === 1) {
          const idx = selEls[0];
          const card = pHand[idx];
          // 惰性氣體
          if (card.usable) {
            setPF((f) => [{ el: card.el, usable: true }, ...f]);
            addLog(`使用 惰性氣體 ${card.el}`);
            setPH((h) => h.filter((_, i) => i !== idx));
          }
          // 1A族引爆水
          else if (ALKALI.includes(card.el) && hasWater) {
            const waterCount = [...pField, ...aField].filter((mol) => mol.name === '水').length;
            const atomNum = ELEMENTS.indexOf(card.el) + 1;
            const waterMol = MOLECULES.find((m) => m.name === '水');
            const waterAtomNum = Object.entries(waterMol.formula).reduce((s, [el, n]) => s + (ELEMENTS.indexOf(el) + 1) * n, 0);
            const dmg = (atomNum + waterAtomNum) * waterCount;
            showToast(`實驗室爆炸了！造成${dmg}點傷害`);
            addLog(`實驗室爆炸了！造成${dmg}點傷害`);
            applyDamage('ai', dmg);
            // 消耗使用的元素牌
            setPH((h) => h.filter((_, i) => i !== idx));
            // 產生對應鹼性分子並移除所有水分子
            const newMolName = card.el === 'Li' ? '氫氧化鋰' : card.el === 'Na' ? '氫氧化鈉' : '氫氧化鉀';
            const newMol = MOLECULES.find((m) => m.name === newMolName);
            setPF((f) => [newMol, ...f.filter((mol) => mol.name !== '水')] );
            setAF((f) => f.filter((mol) => mol.name !== '水'));((f) => f.filter((mol) => mol.name !== '水'));
          } else {
            // 其他元素使用
            addLog(`使用 元素 ${card.el}`);
            setPH((h) => h.filter((_, i) => i !== idx));
          }
          setSelEls([]);
        }
        // 結束玩家回合
        setTurn('ai');
      };  
      React.useEffect(() => {
  if (gameOver || turn !== 'ai') return;

  const newHand = drawCardsTo(aHand, setAH, 2, 'AI');

  const acidCount = pField.filter(m => (m.kind || '').includes('acid')).length;
  const strongAcidCount = pField.filter(m => (m.kind || '').includes('strong_acid')).length;

  if (acidCount === 0) clearCorrosion(newHand, setAH);
  if (strongAcidCount > 0) {
    const corroded = corrodeMetals(newHand, setAH, 1);
    if (corroded > 0) addLog(`你方強酸腐蝕了敵方 ${corroded} 張金屬卡`);
  }

  // 延遲執行行動（給 React 更新時間）
  setTimeout(() => aiTakeAction(), 600);
}, [turn, gameOver]);



      const possibleList=React.useMemo(()=>{const cnt={};pHand.forEach(c=>cnt[c.el]=(cnt[c.el]||0)+1);return MOLECULES.filter(m=>Object.entries(m.formula||{}).every(([el,n])=>cnt[el]>=n)).map(m=>`${m.name} (${Object.entries(m.formula).map(([el,n])=>n>1?`${n}${el}`:el).join(' + ')})`);},[pHand]);  


      //ui區域-----------------------------------------------
      return(<div className="game-container"><div className="board">
        <h1>真實煉金：化合之戰</h1>
        {aiThinking && (
  <div className="overlay">
    <div className="ai-text">AI 思考中...</div>
  </div>
)}
        <img src="https://wen91027.github.io/img/BN_top.jpeg" alt="遊戲首圖" className="bg-logo" />


        {gameOver&&<div className="overlay"><h2>{gameOver==='win'?'你贏了':'化學不會就是不會'}</h2><button onClick={resetGame}>重新開始</button></div>}
        <div className="zone">
  <div className="zone-title">對手手牌</div>
  <div className="hand enemy-hand">
{aHand.map((c, i) => (
 <div key={i}
  className={`card element ${c.usable ? 'inert' : ''}${ALKALI.includes(c.el) ? ' alkali' : ''}${c.corroded ? ' corroded' : ''}${justDrawnIndices.includes(i) ? ' just-drawn' : ''}`}>
       <div className="symbol">{c.el}</div>
        <div className="number">{ELEMENTS.indexOf(c.el) + 1}</div>
        {c.usable && <div className="defense">防禦傷害</div>}
        {ALKALI.includes(c.el) && <div className="explode">引爆水</div>}
      </div>
    ))}
  </div>
</div>
        <div className="hp-section"><span className="hp-label">AI HP</span><div className="hp-bar"><div className="hp-inner" style={{width:`${aHP/MAX_HP*100}%`}}/></div><span>{aHP}</span></div>

        {/* 對手分子區 */}
        <div className="zone"><div className="zone-title">對手分子區</div><div className="field">
           {aField.map((c,i)=>
        <div key={i} className={`card molecule ${c.effect} ${(c.kind || '').includes('acid') ? 'acid' : ''} ${c.usable ? 'inert' : ''}${selEnemyMol === i ? ' selected' : ''}${justCombinedId === c.id ? 'newly-created' : ''}
`}onClick={() => handleSelectEnemyMol(i)}>
            <div className="symbol">{c.usable?c.el:c.name}</div>
            {c.usable&&<div className="block-info">阻擋{ELEMENTS.indexOf(c.el)+1}傷害</div>}
             {c.effect === 'recover' &&
          <div className="recover-info">
            持續回復{RECOVER_CONFIG['水'].perTurn}HP
          </div>
        }
             {c.effect === 'corrosion' && (
    <div className="corrosion-info">腐蝕金屬</div>
  )}
          </div>
        )}</div></div>

        {/* log區 */}
        <div className="log">{log.slice(0,5).map((l,i)=>
          <div key={i} style={{color:i===0?'#ff0':'#ccc'}}>{l}</div>
        )}</div>


        {/* 我方分子區 */}
        <div className="zone"><div className="zone-title">我方分子區</div><div className="field">
          {pField.map((c,i)=>
          <div key={i} className={`card molecule ${c.effect} ${(c.kind || '').includes('acid') ? 'acid' : ''} ${c.usable ? 'inert' : ''}${selMol === i ? ' selected' : ''}${justCombinedId === c.id ? 'newly-created' : ''}
`} onClick={() => handleSelectMol(i)}>           
            {c.usable
              ? React.createElement(React.Fragment, null,
                  React.createElement("div", { className: "symbol" }, c.el),
                  React.createElement("div", { className: "block-info" }, `阻擋${ELEMENTS.indexOf(c.el)+1}傷害`)
                )
              : React.createElement("div", { className: "name" }, c.name)
            }
                    {c.effect === 'recover' &&
          <div className="recover-info">
            持續回復{RECOVER_CONFIG['水'].perTurn}HP
          </div>
        }
              {c.effect === 'corrosion' && (
    <div className="corrosion-info">腐蝕金屬</div>
  )}
            
          </div>
        )}</div></div>

          <div>
      <div>
        {/* 如果可以中和，顯示合成按鈕 */}
 {selMol !== null && selEnemyMol !== null && (
  <button 
    onClick={() => handleNeutralize(pField[selMol], aField[selEnemyMol])}
    disabled={!canCombine}
  >
    中和
  </button>
)}
      </div>
    </div>

        
             <div className="hp-section"><span className="hp-label">玩家 HP</span><div className="hp-bar"><div className="hp-inner" style={{width:`${pHP/MAX_HP*100}%`}}/></div><span>{pHP}</span></div>

        <div className="zone"><div className="zone-title">玩家手牌</div><div className="hand">{pHand.map((c,i)=>
 <div key={i}
  className={`card element ${c.usable ? 'inert' : ''}${ALKALI.includes(c.el) ? ' alkali' : ''}${c.corroded ? ' corroded' : ''}${selEls.includes(i) ? ' selected' : ''}${justDrawnIndices.includes(i) ? ' just-drawn' : ''}${justUsedIndices.includes(i) ? ' combine-out' : ''}`}
  onClick={() => handleSelectEl(i)}>
            <div className="symbol">{c.el}</div>
            <div className="number">{ELEMENTS.indexOf(c.el)+1}</div>
            {c.usable&&<div className="defense">防禦傷害</div>}
            {ALKALI.includes(c.el)&&<div className="explode">引爆水</div>}
          </div>
        )}</div></div>
        <div className="prompt">{possibleList.length>0?`可合成: ${possibleList.join('、')}`:'無可合成化合物'}</div>
        <div className="controls"><button onClick={handleCombine} disabled={turn!=='player'||gameOver||selEls.length<2}>合成</button><button onClick={handleUse} disabled={!canUse}>使用</button><button onClick={handleDiscard} disabled={turn!=='player'||gameOver||selEls.length<1}>棄牌</button><button onClick={handleEnd} disabled={turn!=='player'||gameOver}>結束回合</button></div>
         </div></div>);
    }
    ReactDOM.render(<App/>,document.getElementById('root'));
  </script>
</body>
</html>


